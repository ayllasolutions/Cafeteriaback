const fs = require("fs");
const java = require('java');
const joint = require("./Joint");


/**
 *  BarcodeGenerator for backend barcode images generation.
 *  supported symbologies:
 *  1D:
 *  Codabar, Code11, Code128, Code39Standard, Code39Extended
 *  Code93Standard, Code93Extended, EAN13, EAN8, Interleaved2of5,
 *  MSI, Standard2of5, UPCA, UPCE, ISBN, GS1Code128, Postnet, Planet
 *  EAN14, SCC14, SSCC18, ITF14, SingaporePost ...
 *  2D:
 *  Aztec, DataMatrix, PDf417, QR code ...
 *@example
 * // This sample shows how to create and save a barcode image.
 * let encode_type = EncodeTypes.CODE_128;
 * let generator = new BarcodeGenerator(encode_type);
 * generator.setCodeText("123ABC");
 */
class BarcodeGenerator extends joint.BaseJavaClass
{
    parameters;

    static get javaClassName()
    {
        return "com.aspose.mw.barcode.generation.MwBarcodeGenerator";
    }

    /**
     * BarcodeGenerator constructor.
     * @param encodeType Barcode symbology type. Use EncodeTypes class to setup a symbology
     * @param codeText Text to be encoded.
     * @code
     *   let barcodeGenerator = new BarcodeGenerator(EncodeTypes.EAN_14, "332211");
     * @encode
     * @throws BarcodeException
     */
    constructor(encodeType, codeText)
    {
        let java_class_link = java.import(BarcodeGenerator.javaClassName);
        let java_class = new java_class_link(encodeType, codeText);
        super(java_class);
        this.init();
    }

    static construct(javaClass)
    {
        let barcodeGenerator = new BarcodeGenerator( null, null);
        barcodeGenerator.setJavaClass(javaClass);
        return barcodeGenerator;
    }

    init()
    {
        this.parameters = new BaseGenerationParameters(this.getJavaClass().getParametersSync());
    }

    /**
     * Generation parameters.
     * @return BaseGenerationParameters
     */
    getParameters()
    {
        return this.parameters;
    }


    /**
     * Barcode symbology type.
     */
    getBarcodeType()
    {
        return this.getJavaClass().getBarcodeTypeSync();
    }

    /**
     * Barcode symbology type.
     */
    setBarcodeType(value)
    {
        this.getJavaClass().setBarcodeTypeSync(value);
    }

    /**
     * Generate the barcode image under current settings.
     * This sample shows how to create and save a barcode image.
     * @param {BarCodeImageFormat} format BarCodeImageFormat value (PNG, BMP, JPEG, GIF)
     * @example
     * let generator = new BarCodeGenerator(EncodeTypes.CODE_128);
     * let image = generator.generateBarCodeImage(BarCodeImageFormat.GIF);
     * @return {String} base64 representation of image.
     */
    generateBarCodeImage(format)
    {
        try
        {
            let base64Image = this.getJavaClass().generateBarCodeImageSync(format);
            return (base64Image);
        } catch (e)
        {
            throw new joint.BarcodeException(e)
        }
    }

    /**
     * Save barcode image to specific file in specific format.
     * @param {String} filePath Path to save to.
     * @param {BarCodeImageFormat} format BarCodeImageFormat value (PNG, BMP, JPEG, GIF)
     * @example
     * let generator = new BarCodeGenerator(EncodeTypes.CODE_128);
     * generator.save("file path", BarCodeImageFormat.GIF);
     */
    save(filePath, format)
    {
        let image64 = this.generateBarCodeImage(format);
        let buff = Buffer.from(image64, 'base64');
        fs.writeFileSync(filePath, buff);
    }

    /**
     * Text to be encoded.
     */
    getCodeText()
    {
        return this.getJavaClass().getCodeTextSync();
    }

    /**
     * Text to be encoded.
     */
    setCodeText(value)
    {
        this.getJavaClass().setCodeTextSync(value);
    }

    /**
     * Exports BarCode properties to the xml file specified
     * @param filePath The xml file
     * @return Whether or not export completed successfully. Returns <b>True</b> in case of success; <b>False</b> Otherwise </para>
     * @throws IOException
     */
    exportToXml(filePath)
    {
        try
        {
            let xmlData = this.getJavaClass().exportToXmlSync();
            let isSaved = xmlData != null;
            if (isSaved)
            {
                fs.writeFileSync(filePath, xmlData);
            }
            return isSaved;
        }
        catch (ex)
        {
            throw new BarcodeException(ex.getMessage());
        }
    }

    /**
     * <p>
     * Imports BarCode properties from the xml-file specified and creates BarcodeGenerator instance.
     * </p>
     * @return BarcodeGenerator instance
     * @param filePath The name of  the file
     */
    importFromXml(filePath)
    {
        try
        {
            let xmlData = joint.convertResourceToBase64String(filePath);
            let offset = 6;
            xmlData = xmlData.substr(offset);
            return BarcodeGenerator.construct(java(BarcodeGenerator.javaClassName).importFromXmlSync(xmlData));
        }
        catch (ex)
        {
            throw new BarcodeException(ex.getMessage());
        }
    }
}

/**
 * Barcode generation parameters.
 */
class BarcodeParameters extends joint.BaseJavaClass
{
    xDimension;
    barHeight;
    barCodeWidth;
    barCodeHeight;
    codeTextParameters;
    postal;
    australianPost;
    codablock;
    dataBar;
    gs1CompositeBar;
    dataMatrix;
    code16K;
    itf;
    qr;
    pdf417;
    maxiCode;
    aztec;
    codabar;
    coupon;
    supplement;
    dotCode;
    padding;
    patchCode;
    barWidthReduction;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.xDimension = new Unit(this.getJavaClass().getXDimensionSync());
        this.barWidthReduction = new Unit(this.getJavaClass().getBarWidthReductionSync());
        this.barHeight = new Unit(this.getJavaClass().getBarHeightSync());
        this.barCodeWidth = new Unit(this.getJavaClass().getBarCodeWidthSync());
        this.barCodeHeight = new Unit(this.getJavaClass().getBarCodeHeightSync());
        this.codeTextParameters = new CodetextParameters(this.getJavaClass().getCodeTextParametersSync());
        this.postal = new PostalParameters(this.getJavaClass().getPostalSync());
        this.australianPost = new AustralianPostParameters(this.getJavaClass().getAustralianPostSync());
        this.codablock = new CodablockParameters(this.getJavaClass().getCodablockSync());
        this.dataBar = new DataBarParameters(this.getJavaClass().getDataBarSync());
        this.gs1CompositeBar = new GS1CompositeBarParameters(this.getJavaClass().getGS1CompositeBarSync());
        this.dataMatrix = new DataMatrixParameters(this.getJavaClass().getDataMatrixSync());
        this.code16K = new Code16KParameters(this.getJavaClass().getCode16KSync());
        this.itf = new ITFParameters(this.getJavaClass().getITFSync());
        this.qr = new QrParameters(this.getJavaClass().getQRSync());
        this.pdf417 = new Pdf417Parameters(this.getJavaClass().getPdf417Sync());
        this.maxiCode = new MaxiCodeParameters(this.getJavaClass().getMaxiCodeSync());
        this.aztec = new AztecParameters(this.getJavaClass().getAztecSync());
        this.codabar = new CodabarParameters(this.getJavaClass().getCodabarSync());
        this.coupon = new CouponParameters(this.getJavaClass().getCouponSync());
        this.supplement = new SupplementParameters(this.getJavaClass().getSupplementSync());
        this.dotCode = new DotCodeParameters(this.getJavaClass().getDotCodeSync());
        this.padding = new Padding(this.getJavaClass().getPaddingSync());
        this.patchCode = new PatchCodeParameters(this.getJavaClass().getPatchCodeSync());
    }

    /**
     * x-dimension is the smallest width of the unit of BarCode bars or spaces.
     * Increase this will increase the whole barcode image width.
     * Ignored if AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     */
    getXDimension()
    {
        return this.xDimension;
    }

    /**
     * x-dimension is the smallest width of the unit of BarCode bars or spaces.
     * Increase this will increase the whole barcode image width.
     * Ignored if AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     * @throws BarcodeException
     */
    setXDimension(value)
    {
        this.getJavaClass().setXDimensionSync(value.getJavaClass());
        this.xDimension = value;
    }

    /**
     * Height of 1D barcodes' bars in Unit value.
     * Ignored if AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     * @throws BarcodeException
     */
    getBarHeight()
    {
        return this.barHeight;
    }

    /**
     * Height of 1D barcodes' bars in Unit value.
     * Ignored if AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     * @throws BarcodeException
     */
    setBarHeight(value)
    {
        this.getJavaClass().setBarHeightSync(value.getJavaClass());
        this.barHeight = value;
    }

    /**
     * Bars color.
     * @return value of Bar color
     * Default value: #000000
     */
    getBarColor()
    {
        let intColor = this.getJavaClass().getBarColorSync();
        let hexColor = ((intColor) >>> 0).toString(16).slice(-6).toUpperCase()
        while (hexColor.length < 6)
        {
            hexColor = "0" + hexColor;
        }
        hexColor = "#" + hexColor;
        return hexColor;
    }

    /**
     * Bars color.
     * @param {String} value for Bar color
     * Default value: #000000.
     */
    setBarColor(value)
    {
        this.getJavaClass().setBarColorSync((parseInt(value.substr(1), 16) << 8) / 256);
    }

    /**
     * Barcode paddings.
     * Default value: 5pt 5pt 5pt 5pt.
     */
    getPadding()
    {
        return this.padding;
    }

    /**
     * Barcode paddings.
     * Default value: 5pt 5pt 5pt 5pt.
     */
    setPadding(value)
    {
        this.getJavaClass().setPaddingSync(value.getJavaClass());
        this.padding = value;
    }

    /**
     *  Always display checksum digit in the human readable text for Code128 and GS1Code128 barcodes.
     */
    getChecksumAlwaysShow()
    {
        return this.getJavaClass().getChecksumAlwaysShowSync();
    }

    /**
     *  Always display checksum digit in the human readable text for Code128 and GS1Code128 barcodes.
     */
    setChecksumAlwaysShow(value)
    {
        this.getJavaClass().setChecksumAlwaysShowSync(value);
    }

    /**
     * Enable checksum during generation 1D barcodes.
     * Default is treated as Yes for symbology which must contain checksum, as No where checksum only possible.
     * Checksum is possible: Code39 Standard/Extended, Standard2of5, Interleaved2of5, Matrix2of5, ItalianPost25, DeutschePostIdentcode, DeutschePostLeitcode, VIN, Codabar
     * Checksum always used: Rest symbology
     */
    isChecksumEnabled()
    {
        return this.getJavaClass().isChecksumEnabledSync();
    }

    /**
     * Enable checksum during generation 1D barcodes.
     * Default is treated as Yes for symbology which must contain checksum, as No where checksum only possible.
     * Checksum is possible: Code39 Standard/Extended, Standard2of5, Interleaved2of5, Matrix2of5, ItalianPost25, DeutschePostIdentcode, DeutschePostLeitcode, VIN, Codabar
     * Checksum always used: Rest symbology
     */
    setChecksumEnabled(value)
    {
        this.getJavaClass().setChecksumEnabledSync(value);
    }

    /**
     * Indicates whether explains the character "\" as an escape character in CodeText property. Used for Pdf417, DataMatrix, Code128 only
     * If the EnableEscape is true, "\" will be explained as a special escape character. Otherwise, "\" acts as normal characters.
     *Aspose.BarCode supports inputing decimal ascii code and mnemonic for ASCII control-code characters. For example, \013 and \\CR stands for CR.
     */
    getEnableEscape()
    {
        return this.getJavaClass().getEnableEscapeSync();
    }

    /**
     * Indicates whether explains the character "\" as an escape character in CodeText property. Used for Pdf417, DataMatrix, Code128 only<br>
     * If the EnableEscape is true, "\" will be explained as a special escape character. Otherwise, "\" acts as normal characters.<br>
     *<hr>Aspose.BarCode supports the decimal ascii code and mnemonic for ASCII control-code characters. For example, \013 and \\CR stands for CR.</hr>
     */
    setEnableEscape(value)
    {
        this.getJavaClass().setEnableEscapeSync(value);
    }

    /**
     * Wide bars to Narrow bars ratio<br>.
     * Default value: 3, that is, wide bars are 3 times as wide as narrow bars<br>.
     * Used for ITF, PZN, PharmaCode, Standard2of5, Interleaved2of5, Matrix2of5, ItalianPost25, IATA2of5, VIN, DeutschePost, OPC, Code32, DataLogic2of5, PatchCode, Code39Extended, Code39Standard<br>
     *
     * The WideNarrowRatio parameter value is less than or equal to 0.
     */
    getWideNarrowRatio()
    {
        return this.getJavaClass().getWideNarrowRatioSync();
    }

    /**
     * Wide bars to Narrow bars ratio.<br>
     * Default value: 3, that is, wide bars are 3 times as wide as narrow bars.<br>
     * Used for ITF, PZN, PharmaCode, Standard2of5, Interleaved2of5, Matrix2of5, ItalianPost25, IATA2of5, <br>
     * VIN, DeutschePost, OPC, Code32, DataLogic2of5, PatchCode, Code39Extended, Code39Standard<br>
     *
     * The WideNarrowRatio parameter value is less than or equal to 0.
     */
    setWideNarrowRatio(value)
    {
        this.getJavaClass().setWideNarrowRatioSync(value);
    }

    /**
     * Codetext parameters.
     */
    getCodeTextParameters()
    {
        return this.codeTextParameters;
    }

    /**
     * Gets a value indicating whether bars filled.<br>
     * Only for 1D barcodes.<br>
     * Default value: true.
     */
    getFilledBars()
    {
        return this.getJavaClass().getFilledBarsSync();
    }

    /**
     * Sets a value indicating whether bars filled.<br>
     * Only for 1D barcodes.<br>
     * Default value: true.
     */
    setFilledBars(value)
    {
        this.getJavaClass().setFilledBarsSync(value);
    }

    /**
     * Get bars reduction value that is used to compensate ink spread while printing.<br>
     * @return Unit value of BarWidthReduction
     */
    getBarWidthReduction()
    {
        return this.barWidthReduction;
    }

    /**
     * Sets bars reduction value that is used to compensate ink spread while printing.
     */
    setBarWidthReduction(value)
    {
        this.getJavaClass().setBarWidthReductionSync(value.getJavaClass());
        this.barWidthReduction = value;
    }


    /**
     * Postal parameters. Used for Postnet, Planet.
     */
    getPostal()
    {
        return this.postal;
    }

    /**
     * PatchCode parameters.
     */
    getPatchCode()
    {
        return this.patchCode;
    }


    /**
     * AustralianPost barcode parameters.
     */
    getAustralianPost()
    {
        return this.australianPost;
    }

    /**
     * Databar parameters.
     */
    getDataBar()
    {
        return this.dataBar;
    }

    /**
     * GS1 Composite Bar parameters.
     *
     * This sample shows how to create and save a GS1 Composite Bar image.
     * Note that 1D codetext and 2D codetext are separated by symbol '/'
     *
     * let codetext = "(01)03212345678906/(21)A1B2C3D4E5F6G7H8";
     * let generator = new BarcodeGenerator(EncodeTypes.GS_1_COMPOSITE_BAR, codetext);
     *
     * generator.getParameters().getBarcode().getGS1CompositeBar().setLinearComponentType(EncodeTypes.GS_1_CODE_128);
     * generator.getParameters().getBarcode().getGS1CompositeBar().setTwoDComponentType(TwoDComponentType.CC_A);
     *
     * // Aspect ratio of 2D component
     * generator.getParameters().getBarcode().getPdf417().setAspectRatio(3);
     *
     * // X-Dimension of 1D and 2D components
     * generator.getParameters().getBarcode().getXDimension().setPixels(3);
     * ///
     * // Height of 1D component
     * generator.getParameters().getBarcode().getBarHeight().setPixels(100);
     * ///
     * generator.save("test.png", BarcodeImageFormat.PNG);
     *
     * @return GS1CompositeBarParameters GS1 Composite Bar parameters.
     */
    getGS1CompositeBar()
    {
        return this.gs1CompositeBar;
    }

    /**
     * GS1 Composite Bar parameters.
     *
     * This sample shows how to create and save a GS1 Composite Bar image.
     * Note that 1D codetext and 2D codetext are separated by symbol '/'
     *
     * let codetext = "(01)03212345678906/(21)A1B2C3D4E5F6G7H8";
     * let generator = new BarcodeGenerator(EncodeTypes.GS_1_COMPOSITE_BAR, codetext);
     *
     * generator.getParameters().getBarcode().getGS1CompositeBar().setLinearComponentType(EncodeTypes.GS_1_CODE_128);
     * generator.getParameters().getBarcode().getGS1CompositeBar().setTwoDComponentType(TwoDComponentType.CC_A);
     *
     * // Aspect ratio of 2D component
     * generator.getParameters().getBarcode().getPdf417().setAspectRatio(3);
     *
     * // X-Dimension of 1D and 2D components
     * generator.getParameters().getBarcode().getXDimension().setPixels(3);
     * ///
     * // Height of 1D component
     * generator.getParameters().getBarcode().getBarHeight().setPixels(100);
     * ///
     * generator.save("test.png", BarcodeImageFormat.PNG);
     */
    setGS1CompositeBar(value)
    {
        this.gs1CompositeBar = value;
        this.getJavaClass().setGS1CompositeBarSync(value.getJavaClass());
    }

    /**
     * Codablock parameters.
     */
    getCodablock()
    {
        return this.codablock;
    }

    /**
     * DataMatrix parameters.
     */
    getDataMatrix()
    {
        return this.dataMatrix;
    }

    /**
     * Code16K parameters.
     */
    getCode16K()
    {
        return this.code16K;
    }

    /**
     * DotCode parameters.
     */
    getDotCode()
    {
        return this.dotCode;
    }

    /**
     * ITF parameters.
     */
    getITF()
    {
        return this.itf;
    }

    /**
     * PDF417 parameters.
     */
    getPdf417()
    {
        return this.pdf417;
    }

    /**
     * QR parameters.
     */
    getQR()
    {
        return this.qr;
    }

    /**
     * Supplement parameters. Used for Interleaved2of5, Standard2of5, EAN13, EAN8, UPCA, UPCE, ISBN, ISSN, ISMN.
     */
    getSupplement()
    {
        return this.supplement;
    }

    /**
     * MaxiCode parameters.
     */
    getMaxiCode()
    {
        return this.maxiCode;
    }

    /**
     * Aztec parameters.
     */
    getAztec()
    {
        return this.aztec;
    }

    /**
     * Codabar parameters.
     */
    getCodabar()
    {
        return this.codabar;
    }

    /**
     * Coupon parameters. Used for UpcaGs1DatabarCoupon, UpcaGs1Code128Coupon.
     */
    getCoupon()
    {
        return this.coupon;
    }
}

/**
 * Barcode image generation parameters.
 */
class BaseGenerationParameters extends joint.BaseJavaClass
{
    captionAbove;
    captionBelow;
    barcodeParameters;
    borderParameters;

    imageWidth;
    imageHeight;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.captionAbove = new CaptionParameters(this.getJavaClass().getCaptionAboveSync());
        this.captionBelow = new CaptionParameters(this.getJavaClass().getCaptionBelowSync());
        this.barcodeParameters = new BarcodeParameters(this.getJavaClass().getBarcodeSync());
        this.borderParameters = new BorderParameters(this.getJavaClass().getBorderSync());
        this.imageWidth = new Unit(this.getJavaClass().getImageWidthSync());
        this.imageHeight = new Unit(this.getJavaClass().getImageHeightSync());
    }

    /**
     * Background color of the barcode image.<br>
     * Default value: #FFFFFF<br>
     */
    getBackColor()
    {
        let intColor = this.getJavaClass().getBackColorSync();
        let hexColor = ((intColor) >>> 0).toString(16).slice(-6).toUpperCase()
        while (hexColor.length < 6)
        {
            hexColor = "0" + hexColor;
        }
        hexColor = "#" + hexColor;
        return hexColor;
    }

    /**
     * Background color of the barcode image.<br>
     * Default value: #FFFFFF<br>
     */
    setBackColor(hexValue)
    {
        this.getJavaClass().setBackColorSync((parseInt(hexValue.substr(1), 16) << 8) / 256);
    }

    /**
     * Gets the resolution of the BarCode image.<br>
     * One value for both dimensions.<br>
     * Default value: 96 dpi.<br>
     *
     * The Resolution parameter value is less than or equal to 0.
     */
    getResolution()
    {
        return this.getJavaClass().getResolutionSync();
    }

    /**
     * Sets the resolution of the BarCode image.<br>
     * One value for both dimensions.<br>
     * Default value: 96 dpi.<br>
     *
     * The Resolution parameter value is less than or equal to 0.
     */
    setResolution(value)
    {
        this.getJavaClass().setResolutionSync(java.newFloat(value));
    }

    /**
     *  BarCode image rotation angle, measured in degree, e.g. RotationAngle = 0 or RotationAngle = 360 means no rotation.<br>
     *  If RotationAngle NOT equal to 90, 180, 270 or 0, it may increase the difficulty for the scanner to read the image<br>.
     *  Default value: 0.<br>
     *  @example
     *  //This sample shows how to create and save a BarCode image.
     *     let generator = new BarcodeGenerator( EncodeTypes.DATA_MATRIX);
     *     generator.getParameters().setRotationAngle(7);
     *     generator.save("test.png");
     */
    getRotationAngle()
    {
        return this.getJavaClass().getRotationAngleSync();
    }

    /**
     *  BarCode image rotation angle, measured in degree, e.g. RotationAngle = 0 or RotationAngle = 360 means no rotation.<br>
     *  If RotationAngle NOT equal to 90, 180, 270 or 0, it may increase the difficulty for the scanner to read the image.<br>
     *  Default value: 0.<br>
     *  @example
     *  //This sample shows how to create and save a BarCode image.
     *     let generator = new BarcodeGenerator( EncodeTypes.DATA_MATRIX);
     *     generator.getParameters().setRotationAngle(7);
     *     generator.save("test.png");
     */
    setRotationAngle(value)
    {
        this.getJavaClass().setRotationAngleSync(java.newFloat(value));
    }

    /**
     * Caption Above the BarCode image. See CaptionParameters.
     */
    getCaptionAbove()
    {
        return this.captionAbove;
    }

    /**
     * Caption Above the BarCode image. See CaptionParameters.
     */
    setCaptionAbove(value)
    {
        this.getJavaClass().setCaptionAboveSync(value.getJavaClass());
        this.captionAbove.updateCaption(value);
    }

    /**
     * Caption Below the BarCode image. See CaptionParameters.
     */
    getCaptionBelow()
    {
        return this.captionBelow;
    }

    /**
     * Caption Below the BarCode image. See CaptionParameters.
     */
    setCaptionBelow(value)
    {
        this.getJavaClass().setCaptionBelowSync(value.getJavaClass());
        this.captionBelow.updateCaption(value);
    }

    /**
     * Specifies the different types of automatic sizing modes.<br>
     * Default value: AutoSizeMode.NONE.
     */
    getAutoSizeMode()
    {
        return this.getJavaClass().getAutoSizeModeSync();
    }

    /**
     * Specifies the different types of automatic sizing modes.<br>
     * Default value: AutoSizeMode.NONE.
     */
    setAutoSizeMode(value)
    {
        this.getJavaClass().setAutoSizeModeSync(value + "");
    }


    /**
     * BarCode image height when AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     */
    getImageHeight()
    {
        return this.imageHeight;
    }

    /**
     * BarCode image height when AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     */
    setImageHeight(value)
    {
        this.getJavaClass().setImageHeight(value.getJavaClass());
        this.imageHeight = value;
    }


    /**
     * BarCode image width when AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     */
    getImageWidth()
    {
        return this.imageWidth;
    }

    /**
     * BarCode image width when AutoSizeMode property is set to AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.
     */
    setImageWidth(value)
    {
        this.getJavaClass().setImageWidth(value.getJavaClass());
        this.imageWidth = value;
    }

    /**
     * Gets the BarcodeParameters that contains all barcode properties.
     */
    getBarcode()
    {
        return this.barcodeParameters;
    }

    /**
     * Gets the BarcodeParameters that contains all barcode properties.
     */
    setBarcode(value)
    {
        this.getJavaClass().setBarcodeSync(value.getJavaClass());
        this.barcodeParameters = value;
    }

    /**
     * Gets the BorderParameters that contains all configuration properties for barcode border.
     */
    getBorder()
    {
        return this.borderParameters;
    }
}


/**
 * Barcode image border parameters
 */
class BorderParameters extends joint.BaseJavaClass
{
    width;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.width = new Unit(this.getJavaClass().getWidthSync());
    }

    /**
     * Border visibility. If false than parameter Width is always ignored (0).
     * Default value: false.
     */
    getVisible()
    {
        return this.getJavaClass().getVisibleSync();
    }

    /**
     * Border visibility. If false than parameter Width is always ignored (0).
     * Default value: false.
     */
    setVisible(value)
    {
        this.getJavaClass().setVisibleSync(value);
    }

    /**
     * Border width.<br>
     * Default value: 0.<br>
     * Ignored if Visible is set to false.
     */
    getWidth()
    {
        return this.width;
    }

    /**
     * Border width.<br>
     * Default value: 0.<br>
     * Ignored if Visible is set to false.
     */
    setWidth(value)
    {
        this.getJavaClass().setWidthSync(value.getJavaClass());
        this.width = value;
    }

    /**
     * Returns a human-readable string representation of this BorderParameters.<br>
     * @return A string that represents this BorderParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }

    /**
     * Border dash style.<br>
     * Default value: BorderDashStyle.SOLID.
     */
    getDashStyle()
    {
        return this.getJavaClass().getDashStyleSync();
    }

    /**
     * Border dash style.<br>
     * Default value: BorderDashStyle.SOLID.
     */
    setDashStyle(value)
    {
        this.getJavaClass().setDashStyleSync(value);
    }

    /**
     * Border color.<br>
     * Default value: #000000
     */
    getColor()
    {
        let intColor = this.getJavaClass().getColorSync();
        let hexColor = ((intColor) >>> 0).toString(16).slice(-6).toUpperCase()
        while (hexColor.length < 6)
        {
            hexColor = "0" + hexColor;
        }
        hexColor = "#" + hexColor;
        return hexColor;
    }

    /**
     * Border color.<br>
     * Default value: #000000
     */
    setColor(hexValue)
    {
        this.getJavaClass().setColorSync((parseInt(hexValue.substr(1), 16) << 8) / 256);
    }
}

/**
 * Enable checksum validation during recognition for 1D barcodes.
 * Default is treated as Yes for symbologies which must contain checksum, as No where checksum only possible.
 * Checksum never used: Codabar
 * Checksum is possible: Code39 Standard/Extended, Standard2of5, Interleaved2of5, Matrix2of5, ItalianPost25, DeutschePostIdentcode, DeutschePostLeitcode, VIN
 * Checksum always used: Rest symbologies
 * @example
 * //This sample shows influence of ChecksumValidation on recognition quality and results
 * let generator = new BarcodeGenerator(EncodeTypes.EAN_13, "1234567890128");
 * generator.save("test.png");
 * let reader = new BarCodeReader("test.png", DecodeType.EAN_13);
 * //checksum disabled
 * reader.setChecksumValidation(ChecksumValidation.OFF);
 * reader.readBarCodes().forEach(function(result, i, results)
 * {
 *    console.log("BarCode CodeText: " + result.getCodeText());
 *    console.log("BarCode Value: " + result.getExtended().getOneD().getValue());
 *    console.log("BarCode Checksum: " + result.getExtended().getOneD().getCheckSum());
 * });
 * let reader = new BarCodeReader("test.png", DecodeType.EAN_13);
 * //checksum enabled
 * reader.setChecksumValidation(ChecksumValidation.ON);
 * reader.readBarCodes().forEach(function(result, i, results)
 * {
 *    console.log("BarCode CodeText: " + result.getCodeText());
 *    console.log("BarCode Value: " + result.getExtended().getOneD().getValue());
 *    console.log("BarCode Checksum: " + result.getExtended().getOneD().getCheckSum());
 * });
 * @enum
 */
ChecksumValidation =
    {
        /**
         *    If checksum is required by the specification - it will be validated.
         */
        DEFAULT: 0,

        /**
         *    Always validate checksum if possible.
         */
        ON: 1,

        /**
         *    Do not validate checksum.
         */
        OFF: 2
    };

/**
 * Caption parameters.
 */
class CaptionParameters extends joint.BaseJavaClass
{

    font;
    padding;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.padding = new Padding(this.getJavaClass().getPaddingSync());
        this.font = new FontUnit(this.getJavaClass().getFontSync());
    }

    /**
     * Caption text.<br>
     * Default value: empty string.
     */
    getText()
    {
        return this.getJavaClass().getTextSync();
    }

    /**
     * Caption text.<br>
     * Default value: empty string.
     */
    setText(value)
    {
        this.getJavaClass().setTextSync(value);
    }

    /**
     * Caption font.<br>
     * Default value: Arial 8pt regular.
     */
    getFont()
    {
        return this.font;
    }

    /**
     * Caption text visibility.<br>
     * Default value: false.
     */
    getVisible()
    {
        return this.getJavaClass().getVisibleSync();
    }

    /**
     * Caption text visibility.<br>
     * Default value: false.
     */
    setVisible(value)
    {
        this.getJavaClass().setVisibleSync(value);
    }

    /**
     * Caption text color.<br>
     * Default value BLACK.
     */
    getTextColor()
    {
        let intColor = this.getJavaClass().getTextColorSync();
        let hexColor = ((intColor) >>> 0).toString(16).slice(-6).toUpperCase()
        while (hexColor.length < 6)
        {
            hexColor = "0" + hexColor;
        }
        hexColor = "#" + hexColor;
        return hexColor;
    }

    /**
     * Caption text color.<br>
     * Default value BLACK.
     */
    setTextColor(hexValue)
    {
        this.getJavaClass().setTextColorSync((parseInt(hexValue.substr(1), 16) << 8) / 256);
    }

    /**
     * Captions paddings.<br>
     * Default value for CaptionAbove: 5pt 5pt 0 5pt.<br>
     * Default value for CaptionBelow: 0 5pt 5pt 5pt.
     */
    getPadding()
    {
        return this.padding;
    }

    /**
     * Captions paddings.<br>
     * Default value for CaptionAbove: 5pt 5pt 0 5pt.<br>
     * Default value for CaptionBelow: 0 5pt 5pt 5pt.
     */
    setPadding(value)
    {
        this.getJavaClass().setPaddingSync(value.getJavaClass());
        this.padding = value;
    }

    /**
     * Caption test horizontal alignment.<br>
     * Default valueAlignment.Center.
     */
    getAlignment()
    {
        return this.getJavaClass().getAlignmentSync();
    }

    /**
     * Caption test horizontal alignment.<br>
     * Default valueAlignment.Center.
     */
    setAlignment(value)
    {
        this.getJavaClass().setAlignmentSync(value);
    }

    /**
     * Specify word wraps (line breaks) within text.<br>
     * Default value: false.
     */
    getNoWrap()
    {
        return this.getJavaClass().getNoWrapSync();
    }

    /**
     * Specify word wraps (line breaks) within text.<br>
     * Default value: false.
     */
    setNoWrap(value)
    {
        this.getJavaClass().setNoWrapSync(value);
    }
}

/**
 *  Specifies the size value in different units (Pixel, Inches, etc.).
 *  @example
 *  //This sample shows how to create and save a BarCode image.
 *    let generator = new BarcodeGenerator(EncodeTypes.CODE_128);
 *    generator.getParameters().getBarcode().getBarHeight().setMillimeters(10);
 *    generator.save("test.png");
 */
class Unit extends joint.BaseJavaClass
{
    constructor(source)
    {
        super(Unit.initUnit(source));
        this.init();
    }

    static initUnit(source)
    {
        if (source instanceof Unit)
        {
            return source.getJavaClass();
        }
        return source;
    }

    init()
    {
    }

    /**
     * Gets size value in pixels.
     */
    getPixels()
    {
        return this.getJavaClass().getPixelsSync();
    }

    /**
     * Sets size value in pixels.
     */
    setPixels(value)
    {
        this.getJavaClass().setPixelsSync(value);
    }

    /**
     * Gets size value in inches.
     */
    getInches()
    {
        return this.getJavaClass().getInchesSync();
    }

    /**
     * Sets size value in inches.
     */
    setInches(value)
    {
        this.getJavaClass().setInchesSync(value);
    }

    /**
     * Gets size value in millimeters.
     */
    getMillimeters()
    {
        return this.getJavaClass().getMillimetersSync();
    }

    /**
     * Sets size value in millimeters.
     */
    setMillimeters(value)
    {
        this.getJavaClass().setMillimetersSync(value);
    }

    /**
     * Gets size value in point.
     */
    getPoint()
    {
        return this.getJavaClass().getPointSync();
    }

    /**
     * Sets size value in point.
     */
    setPoint(value)
    {
        this.getJavaClass().setPointSync(value);
    }

    /**
     * Gets size value in document units.
     */
    getDocument()
    {
        return this.getJavaClass().getDocumentSync();
    }

    /**
     * Sets size value in document units.
     */
    setDocument(value)
    {
        this.getJavaClass().setDocumentSync(value);
    }

    /**
     * Returns a human-readable string representation of this Unit.
     * @return A string that represents this Unit.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }

    /**
     * Determines whether this instance and a specified object,<br>
     * which must also be a Unit object, have the same value.<br>
     * @param obj The Unit to compare to this instance.
     * @return true if obj is a Unit and its value is the same as this instance;
     * otherwise, false. If obj is null, the method returns false.
     */
    equals(obj)
    {
        return this.getJavaClass().equalsSync(obj.getJavaClass());
    }
}

/**
 * Paddings parameters.
 */
class Padding extends joint.BaseJavaClass
{

    top;
    bottom;
    right;
    left;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.top = new Unit(this.getJavaClass().getTopSync());
        this.bottom = new Unit(this.getJavaClass().getBottomSync());
        this.right = new Unit(this.getJavaClass().getRightSync());
        this.left = new Unit(this.getJavaClass().getLeftSync());
    }

    /**
     * Top padding.
     */
    getTop()
    {
        return this.top;
    }

    /**
     * Top padding.
     */
    setTop(value)
    {
        this.getJavaClass().setTopSync(value.getJavaClass());
        this.top = value;
    }

    /**
     * Bottom padding.
     */
    getBottom()
    {
        return this.bottom;
    }

    /**
     * Bottom padding.
     */
    setBottom(value)
    {
        this.getJavaClass().setBottomSync(value.getJavaClass());
        this.bottom = value;
    }

    /**
     * Right padding.
     */
    getRight()
    {
        return this.right;
    }

    /**
     * Right padding.
     */
    setRight(value)
    {
        this.getJavaClass().setRightSync(value.getJavaClass());
        this.right = value;
    }

    /**
     * Left padding.
     */
    getLeft()
    {
        return this.left;
    }

    /**
     * Left padding.
     */
    setLeft(value)
    {
        this.getJavaClass().setLeftSync(value.getJavaClass());
        this.left = value;
    }

    /**
     * Returns a human-readable string representation of this Padding.
     * @return A string that represents this Padding.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Codetext parameters.
 */
class CodetextParameters extends joint.BaseJavaClass
{

    font;
    space;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.font = new FontUnit(this.getJavaClass().getFontSync());
        this.space = new Unit(this.getJavaClass().getSpaceSync());
    }

    /**
     * Text that will be displayed instead of codetext in 2D barcodes.<br>
     * Used for: Aztec, Pdf417, DataMatrix, QR, MaxiCode, DotCode
     */
    getTwoDDisplayText()
    {
        return this.getJavaClass().getTwoDDisplayTextSync();
    }

    /**
     * Text that will be displayed instead of codetext in 2D barcodes.<br>
     * Used for: Aztec, Pdf417, DataMatrix, QR, MaxiCode, DotCode
     */
    setTwoDDisplayText(value)
    {
        this.getJavaClass().setTwoDDisplayTextSync(value);
    }

    /**
     * Specify FontMode. If FontMode is set to Auto, font size will be calculated automatically based on xDimension value.<br>
     * It is recommended to use FontMode.AUTO especially in AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.<br>
     * Default value: FontMode.AUTO.
     */
    getFontMode()
    {
        return this.getJavaClass().getFontModeSync();
    }

    /**
     * Specify FontMode. If FontMode is set to Auto, font size will be calculated automatically based on xDimension value.<br>
     * It is recommended to use FontMode.AUTO especially in AutoSizeMode.NEAREST or AutoSizeMode.INTERPOLATION.<br>
     * Default value: FontMode.AUTO.
     */
    setFontMode(value)
    {
        this.getJavaClass().setFontModeSync(value);
    }

    /**
     * Specify the displaying CodeText's font.<br>
     * Default value: Arial 5pt regular.<br>
     * Ignored if FontMode is set to FontMode.AUTO.
     */
    getFont()
    {
        return this.font;
    }

    /**
     * Specify the displaying CodeText's font.<br>
     * Default value: Arial 5pt regular.<br>
     * Ignored if FontMode is set to FontMode.AUTO.
     */
    setFont(value)
    {
        this.getJavaClass().setFontSync(value.getJavaClass());
        this.font = value;
    }

    /**
     * Space between the CodeText and the BarCode in Unit value.<br>
     * Default value: 2pt.<br>
     * Ignored for EAN8, EAN13, UPCE, UPCA, ISBN, ISMN, ISSN, UpcaGs1DatabarCoupon.
     */
    getSpace()
    {
        return this.space;
    }

    /**
     * Space between the CodeText and the BarCode in Unit value.<br>
     * Default value: 2pt.<br>
     * Ignored for EAN8, EAN13, UPCE, UPCA, ISBN, ISMN, ISSN, UpcaGs1DatabarCoupon.
     */
    setSpace(value)
    {
        this.getJavaClass().setSpaceSync(value.getJavaClass());
        this.space = value;
    }

    /**
     * Gets or sets the alignment of the code text.<br>
     * Default value: TextAlignment.CENTER.
     */
    getAlignment()
    {
        return this.getJavaClass().getAlignmentSync();
    }

    /**
     * Gets or sets the alignment of the code text.<br>
     * Default value: TextAlignment.CENTER.
     */
    setAlignment(value)
    {
        this.getJavaClass().setAlignmentSync(value);
    }

    /**
     * Specify the displaying CodeText's Color.<br>
     * Default value BLACK.
     */
    getColor()
    {
        let intColor = this.getJavaClass().getColorSync();
        let hexColor = ((intColor) >>> 0).toString(16).slice(-6).toUpperCase()
        while (hexColor.length < 6)
        {
            hexColor = "0" + hexColor;
        }
        hexColor = "#" + hexColor;
        return hexColor;
    }

    /**
     * Specify the displaying CodeText's Color.<br>
     * Default value BLACK.
     */
    setColor(value)
    {
        this.getJavaClass().setColorSync((parseInt(value.substr(1), 16) << 8) / 256);
    }

    /**
     * Specify the displaying CodeText Location, set to CodeLocation.NONE to hide CodeText.<br>
     * Default value:  CodeLocation.BELOW.
     */
    getLocation()
    {
        return this.getJavaClass().getLocationSync();
    }

    /**
     * Specify the displaying CodeText Location, set to  CodeLocation.NONE to hide CodeText.<br>
     * Default value:  CodeLocation.BELOW.
     */
    setLocation(value)
    {
        this.getJavaClass().setLocationSync(value);
    }

    /**
     * Specify word wraps (line breaks) within text.<br>
     * Default value: false.
     */
    getNoWrap()
    {
        return this.getJavaClass().getNoWrapSync();
    }

    /**
     * Specify word wraps (line breaks) within text.<br>
     * Default value: false.
     */
    setNoWrap(value)
    {
        this.getJavaClass().setNoWrapSync(value);
    }

    /**
     * Returns a human-readable string representation of this CodetextParameters.<br>
     * @return A string that represents this CodetextParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Postal parameters. Used for Postnet, Planet.
 */
class PostalParameters extends joint.BaseJavaClass
{

    postalShortBarHeight;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.postalShortBarHeight = new Unit(this.getJavaClass().getPostalShortBarHeightSync());
    }

    /**
     * Short bar's height of Postal barcodes.
     */
    getPostalShortBarHeight()
    {
        return this.postalShortBarHeight;
    }

    /**
     * Short bar's height of Postal barcodes.
     */
    setPostalShortBarHeight(value)
    {
        this.getJavaClass().setPostalShortBarHeightSync(value.getJavaClass());
        this.postalShortBarHeight = value;
    }

    /**
     * Returns a human-readable string representation of this PostalParameters.<br>
     * @return A string that represents this PostalParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * AustralianPost barcode parameters.
 */
class AustralianPostParameters extends joint.BaseJavaClass
{
    australianPostShortBarHeight;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.australianPostShortBarHeight = new Unit(this.getJavaClass().getAustralianPostShortBarHeightSync());
    }

    /**
     * Short bar's height of AustralianPost barcode.
     */
    getAustralianPostShortBarHeight()
    {
        return this.australianPostShortBarHeight;
    }

    /**
     * Short bar's height of AustralianPost barcode.
     */
    setAustralianPostShortBarHeight(value)
    {
        this.getJavaClass().setAustralianPostShortBarHeightSync(value.getJavaClass());
        this.australianPostShortBarHeight = value;
    }

    /**
     * Interpreting type for the Customer Information of AustralianPost, default to CustomerInformationInterpretingType.Other"
     */
    getAustralianPostEncodingTable()
    {
        return this.getJavaClass().getAustralianPostEncodingTableSync();
    }

    /**
     * Interpreting type for the Customer Information of AustralianPost, default to CustomerInformationInterpretingType.Other"
     */
    setAustralianPostEncodingTable(value)
    {
        this.getJavaClass().setAustralianPostEncodingTableSync(value);
    }

    /**
     * Returns a human-readable string representation of this AustralianPostParameters.<br>
     * @return {string}  Value that represents this AustralianPostParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Codablock parameters.
 */
class CodablockParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Columns count.
     */
    getColumns()
    {
        return this.getJavaClass().getColumnsSync();
    }

    /**
     * Columns count.
     */
    setColumns(value)
    {
        this.getJavaClass().setColumnsSync(value);
    }

    /**
     * Rows count.
     */
    getRows()
    {
        return this.getJavaClass().getRowsSync();
    }

    /**
     * Rows count.
     */
    setRows(value)
    {
        this.getJavaClass().setRowsSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Returns a human-readable string representation of this CodablockParameters. <br>
     * @return {string} value that represents this CodablockParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Databar parameters.
 */
class DataBarParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Enables flag of 2D composite component with DataBar barcode
     */
    is2DCompositeComponent()
    {
        return this.getJavaClass().is2DCompositeComponentSync();
    }

    /**
     * Enables flag of 2D composite component with DataBar barcode
     */
    set2DCompositeComponent(value)
    {
        this.getJavaClass().set2DCompositeComponentSync(value);
    }

    /**
     * If this flag is set, it allows only GS1 encoding standard for Databar barcode types
     */
    isAllowOnlyGS1Encoding()
    {
        return this.getJavaClass().isAllowOnlyGS1EncodingSync();
    }

    /**
     * If this flag is set, it allows only GS1 encoding standard for Databar barcode types
     */
    setAllowOnlyGS1Encoding(value)
    {
        this.getJavaClass().setAllowOnlyGS1EncodingSync(value);
    }

    /**
     * Columns count.
     */
    getColumns()
    {
        return this.getJavaClass().getColumnsSync();
    }

    /**
     * Columns count.
     */
    setColumns(value)
    {
        this.getJavaClass().setColumnsSync(value);
    }

    /**
     * Rows count.
     */
    getRows()
    {
        return this.getJavaClass().getRowsSync();
    }

    /**
     * Rows count.
     */
    setRows(value)
    {
        this.getJavaClass().setRowsSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     * Used for DataBar stacked.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.<br>
     * Used for DataBar stacked.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Returns a human-readable string representation of this DataBarParameters.<br>
     * @return A string that represents this DataBarParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * DataMatrix parameters.
 */
class DataMatrixParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Gets a Datamatrix ECC type.<br>
     * Default value: DataMatrixEccType.ECC_200.
     */
    getDataMatrixEcc()
    {
        return this.getJavaClass().getDataMatrixEccSync();
    }

    /**
     * Sets a Datamatrix ECC type.<br>
     * Default value: DataMatrixEccType.ECC_200.
     */
    setDataMatrixEcc(value)
    {
        this.getJavaClass().setDataMatrixEccSync(value);
    }

    /**
     * Encode mode of Datamatrix barcode.<br>
     * Default value: DataMatrixEncodeMode.AUTO.
     */
    getDataMatrixEncodeMode()
    {
        return this.getJavaClass().getDataMatrixEncodeModeSync();
    }

    /**
     * Encode mode of Datamatrix barcode.<br>
     * Default value: DataMatrixEncodeMode.AUTO.
     */
    setDataMatrixEncodeMode(value)
    {
        this.getJavaClass().setDataMatrixEncodeModeSync(value);
    }

    /**
     * ISO/IEC 16022<br>
     * 5.2.4.7 Macro characters<br>
     * 11.3 Protocol for Macro characters in the first position (ECC 200 only)<br>
     * Macro Characters 05 and 06 values are used to obtain more compact encoding in special modes.<br>
     * Can be used only with DataMatrixEccType.ECC_200 or DataMatrixEccType.ECC_AUTO.<br>
     * Cannot be used with EncodeTypes.GS_1_DATA_MATRIX<br>
     * Default value: MacroCharacter.NONE.
     */
    getMacroCharacters()
    {
        return this.getJavaClass().getMacroCharactersSync();
    }

    /**
     * ISO/IEC 16022<br>
     * 5.2.4.7 Macro characters<br>
     * 11.3 Protocol for Macro characters in the first position (ECC 200 only)<br>
     * Macro Characters 05 and 06 values are used to obtain more compact encoding in special modes.<br>
     * Can be used only with DataMatrixEccType.ECC_200 or DataMatrixEccType.ECC_AUTO.<br>
     * Cannot be used with EncodeTypes.GS_1_DATA_MATRIX<br>
     * Default value: MacroCharacter.NONE.
     */
    setMacroCharacters(value)
    {
        this.getJavaClass().setMacroCharactersSync(value);
    }

    /**
     * Columns count.
     */
    getColumns()
    {
        return this.getJavaClass().getColumnsSync();
    }

    /**
     * Columns count.
     */
    setColumns(value)
    {
        this.getJavaClass().setColumnsSync(value);
    }

    /**
     * Rows count.
     */
    getRows()
    {
        return this.getJavaClass().getRowsSync();
    }

    /**
     * Rows count.
     */
    setRows(value)
    {
        this.getJavaClass().setRowsSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Gets the encoding of codetext.<br>
     * Default value: UTF-16
     */
    getCodeTextEncoding()
    {
        return this.getJavaClass().getCodeTextEncodingSync();
    }

    /**
     * Sets the encoding of codetext.<br>
     * Default value: UTF-16
     */
    setCodeTextEncoding(value)
    {
        this.getJavaClass().setCodeTextEncodingSync(value);
    }

    /**
     * Returns a human-readable string representation of this DataMatrixParameters.<br>
     * @return presentation of this DataMatrixParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * PatchCode parameters.
 */
class PatchCodeParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Specifies codetext for an extra QR barcode, when PatchCode is generated in page mode.
     */
    getExtraBarcodeText()
    {
        return this.getJavaClass().getExtraBarcodeTextSync();
    }

    /**
     * Specifies codetext for an extra QR barcode, when PatchCode is generated in page mode.
     */
    setExtraBarcodeText(value)
    {
        this.getJavaClass().setExtraBarcodeTextSync(value);
    }

    /**
     * PatchCode format. Choose PatchOnly to generate single PatchCode. Use page format to generate Patch page with PatchCodes as borders.<br>
     * Default value: PatchFormat.PATCH_ONLY
     *
     * @return PatchFormat
     */
    getPatchFormat()
    {
        return this.getJavaClass().getPatchFormatSync();
    }

    /**
     * PatchCode format. Choose PatchOnly to generate single PatchCode. Use page format to generate Patch page with PatchCodes as borders.<br>
     * Default value: PatchFormat.PATCH_ONLY
     */
    setPatchFormat(value)
    {
        this.getJavaClass().setPatchFormatSync(value);
    }

    /**
     * Returns a human-readable string representation of this {PatchCodeParameters}<br>
     * @return  string value that represents PatchCodeParameters
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Code16K parameters.
 */
class Code16KParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Size of the left quiet zone in xDimension.<br>
     * Default value: 10, meaning if xDimension = 2px than left quiet zone will be 20px.
     */
    getQuietZoneLeftCoef()
    {
        return this.getJavaClass().getQuietZoneLeftCoefSync();
    }

    /**
     * Size of the left quiet zone in xDimension.<br>
     * Default value: 10, meaning if xDimension = 2px than left quiet zone will be 20px.
     */
    setQuietZoneLeftCoef(value)
    {
        this.getJavaClass().setQuietZoneLeftCoefSync(value);
    }

    /**
     * Size of the right quiet zone in xDimension.<br>
     * Default value: 1, meaning if xDimension = 2px than right quiet zone will be 2px.
     */
    getQuietZoneRightCoef()
    {
        return this.getJavaClass().getQuietZoneRightCoefSync();
    }

    /**
     * Size of the right quiet zone in xDimension.<br>
     * Default value: 1, meaning if xDimension = 2px than right quiet zone will be 2px.
     */
    setQuietZoneRightCoef(value)
    {
        this.getJavaClass().setQuietZoneRightCoefSync(value);
    }

    /**
     * Returns a human-readable string representation of this Code16KParameters.<br>
     * @return A string that represents this Code16KParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * DotCode parameters.
 */
class DotCodeParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Mask of Dotcode barcode.<br>
     * Default value: -1.
     */
    getDotCodeMask()
    {
        return this.getJavaClass().getDotCodeMaskSync();
    }

    /**
     * Mask of Dotcode barcode.<br>
     * Default value: -1.
     */
    setDotCodeMask(value)
    {
        this.getJavaClass().setDotCodeMaskSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Returns a human-readable string representation of this DotCodeParameters.<br>
     * @return A string that represents this DotCodeParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

class GS1CompositeBarParameters extends joint.BaseJavaClass
{
    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Linear component type
     */
    getLinearComponentType()
    {
        return this.getJavaClass().getLinearComponentTypeSync();
    }

    /**
     * Linear component type
     */
    setLinearComponentType(value)
    {
        this.getJavaClass().setLinearComponentTypeSync(value);
    }

    /**
     * 2D component type
     */
    getTwoDComponentType()
    {
        return this.getJavaClass().getTwoDComponentTypeSync();
    }

    /**
     * 2D component type
     */
    setTwoDComponentType(value)
    {
        this.getJavaClass().setTwoDComponentTypeSync(value);
    }

    /**
     * Returns a human-readable string representation of this <see cref="DataBarParameters"/>.
     * @return A string that represents this <see cref="DataBarParameters"/>
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * ITF parameters.
 */
class ITFParameters extends joint.BaseJavaClass
{

    itfBorderThickness;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.itfBorderThickness = new Unit(this.getJavaClass().getItfBorderThicknessSync());
    }

    /**
     * Gets or sets an ITF border (bearer bar) thickness in Unit value.<br>
     * Default value: 12pt.
     */
    getItfBorderThickness()
    {
        return this.itfBorderThickness;
    }

    /**
     * Gets or sets an ITF border (bearer bar) thickness in Unit value.<br>
     * Default value: 12pt.
     */
    setItfBorderThickness(value)
    {
        this.getJavaClass().setItfBorderThicknessSync(value.getJavaClass());
        this.itfBorderThickness = value;
    }

    /**
     * Border type of ITF barcode.<br>
     * Default value: ITF14BorderType.BAR.
     */
    getItfBorderType()
    {
        return this.getJavaClass().getItfBorderTypeSync();
    }

    /**
     * Border type of ITF barcode.<br>
     * Default value: ITF14BorderType.BAR.
     */
    setItfBorderType(value)
    {
        this.getJavaClass().setItfBorderTypeSync(value);
    }

    /**
     * Size of the quiet zones in xDimension.<br>
     * Default value: 10, meaning if xDimension = 2px than quiet zones will be 20px.<br>
     * @exception IllegalArgumentException
     * The QuietZoneCoef parameter value is less than 10.
     */
    getQuietZoneCoef()
    {
        return this.getJavaClass().getQuietZoneCoefSync();
    }

    /**
     * Size of the quiet zones in xDimension.<br>
     * Default value: 10, meaning if xDimension = 2px than quiet zones will be 20px.<br>
     * @exception IllegalArgumentException
     * The QuietZoneCoef parameter value is less than 10.
     */
    setQuietZoneCoef(value)
    {
        this.getJavaClass().setQuietZoneCoefSync(value);
    }

    /**
     * Returns a human-readable string representation of this ITFParameters.<br>
     * @return A string that represents this ITFParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * QR parameters.
 */
class QrParameters extends joint.BaseJavaClass
{
    structuredAppend;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this.structuredAppend = new QrStructuredAppendParameters(this.getJavaClass().getStructuredAppendSync());
    }

    /**
     * QR structured append parameters.
     */
    getStructuredAppend()
    {
        return this.structuredAppend;
    }

    /**
     * QR structured append parameters.
     */
    setStructuredAppend(value)
    {
        this.structuredAppend = value;
        this.getJavaClass().setStructuredAppendSync(value.getJavaClass());
    }

    /**
     * Extended Channel Interpretation Identifiers. It is used to tell the barcode reader details<br>
     * about the used references for encoding the data in the symbol.<br>
     * Current implementation consists all well known charset encodings.
     */
    getQrECIEncoding()
    {
        return this.getJavaClass().getQrECIEncodingSync();
    }

    /**
     * Extended Channel Interpretation Identifiers. It is used to tell the barcode reader details<br>
     * about the used references for encoding the data in the symbol.<br>
     * Current implementation consists all well known charset encodings.
     */
    setQrECIEncoding(value)
    {
        this.getJavaClass().setQrECIEncodingSync(value);
    }

    /**
     * QR symbology type of BarCode's encoding mode.<br>
     * Default value: QREncodeMode.AUTO.
     */
    getQrEncodeMode()
    {
        return this.getJavaClass().getQrEncodeModeSync();
    }

    /**
     * QR symbology type of BarCode's encoding mode.<br>
     * Default value: QREncodeMode.AUTO.
     */
    setQrEncodeMode(value)
    {
        console.log("JS QrParameters.setQrEncodeMode(" + value + ")\n")
        this.getJavaClass().setQrEncodeModeSync(value);
    }

    /**
     * QR / MicroQR selector mode. Select ForceQR for standard QR symbols, Auto for MicroQR.
     */
    getQrEncodeType()
    {
        let value = this.getJavaClass().getQrEncodeTypeSync();
        return value;
    }

    /**
     * QR / MicroQR selector mode. Select ForceQR for standard QR symbols, Auto for MicroQR.
     */
    setQrEncodeType(value)
    {
        this.getJavaClass().setQrEncodeTypeSync(value);
    }

    /**
     *  Level of Reed-Solomon error correction for QR barcode.<br>
     *  From low to high: LEVEL_L, LEVEL_M, LEVEL_Q, LEVEL_H. see QRErrorLevel.
     */
    getQrErrorLevel()
    {
        return this.getJavaClass().getQrErrorLevelSync();
    }

    /**
     *  Level of Reed-Solomon error correction for QR barcode.<br>
     *  From low to high: LEVEL_L, LEVEL_M, LEVEL_Q, LEVEL_H. see QRErrorLevel.
     */
    setQrErrorLevel(value)
    {
        this.getJavaClass().setQrErrorLevelSync(value);
    }

    /**
     * Version of QR Code.<br>
     * From Version1 to Version40 for QR code and from M1 to M4 for MicroQr.<br>
     * Default value is QRVersion.AUTO.
     */
    getQrVersion()
    {
        return this.getJavaClass().getQrVersionSync();
    }

    /**
     * Version of QR Code.<br>
     * From Version1 to Version40 for QR code and from M1 to M4 for MicroQr.<br>
     * Default value is QRVersion.AUTO.
     */
    setQrVersion(value)
    {
        this.getJavaClass().setQrVersionSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Gets the encoding of codetext.<br>
     * Default value: UTF-8
     */
    getCodeTextEncoding()
    {
        return this.getJavaClass().getCodeTextEncodingSync();
    }

    /**
     * Sets the encoding of codetext.<br>
     * Default value: UTF-8
     */
    setCodeTextEncoding(value)
    {
        this.getJavaClass().setCodeTextEncodingSync(value);
    }

    /**
     * Returns a human-readable string representation of this QrParameters.<br>
     * @return A string that represents this QrParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * PDF417 parameters.
 */
class Pdf417Parameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Pdf417 symbology type of BarCode's compaction mode.<br>
     * Default value: Pdf417CompactionMode.AUTO.
     */
    getPdf417CompactionMode()
    {
        return this.getJavaClass().getPdf417CompactionModeSync();
    }

    /**
     * Pdf417 symbology type of BarCode's compaction mode.<br>
     * Default value: Pdf417CompactionMode.AUTO.
     */
    setPdf417CompactionMode(value)
    {
        this.getJavaClass().setPdf417CompactionModeSync(value);
    }

    /**
     * Gets or sets Pdf417 symbology type of BarCode's error correction level<br>
     * ranging from level0 to level8, level0 means no error correction info,<br>
     * level8 means best error correction which means a larger picture.
     */
    getPdf417ErrorLevel()
    {
        return this.getJavaClass().getPdf417ErrorLevelSync();
    }

    /**
     * Gets or sets Pdf417 symbology type of BarCode's error correction level<br>
     * ranging from level0 to level8, level0 means no error correction info,<br>
     * level8 means best error correction which means a larger picture.
     */
    setPdf417ErrorLevel(value)
    {
        this.getJavaClass().setPdf417ErrorLevelSync(value);
    }

    /**
     * Whether Pdf417 symbology type of BarCode is truncated (to reduce space).
     */
    getPdf417Truncate()
    {
        return this.getJavaClass().getPdf417TruncateSync();
    }

    /**
     * Whether Pdf417 symbology type of BarCode is truncated (to reduce space).
     */
    setPdf417Truncate(value)
    {
        this.getJavaClass().setPdf417TruncateSync(value);
    }

    /**
     * Columns count.
     */
    getColumns()
    {
        return this.getJavaClass().getColumnsSync();
    }

    /**
     * Columns count.
     */
    setColumns(value)
    {
        this.getJavaClass().setColumnsSync(value);
    }

    /**
     * Rows count.
     */
    getRows()
    {
        return this.getJavaClass().getRowsSync();
    }

    /**
     * Rows count.
     */
    setRows(value)
    {
        this.getJavaClass().setRowsSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Getsmacro Pdf417 barcode's file ID.<br>
     * Used for MacroPdf417.
     */
    getPdf417MacroFileID()
    {
        return this.getJavaClass().getPdf417MacroFileIDSync();
    }

    /**
     * Sets macro Pdf417 barcode's file ID.<br>
     * Used for MacroPdf417.
     */
    setPdf417MacroFileID(value)
    {
        this.getJavaClass().setPdf417MacroFileIDSync(value);
    }

    /**
     * Gets macro Pdf417 barcode's segment ID, which starts from 0, to MacroSegmentsCount - 1.
     */
    getPdf417MacroSegmentID()
    {
        return this.getJavaClass().getPdf417MacroSegmentIDSync();
    }

    /**
     * Sets macro Pdf417 barcode's segment ID, which starts from 0, to MacroSegmentsCount - 1.
     */
    setPdf417MacroSegmentID(value)
    {
        this.getJavaClass().setPdf417MacroSegmentIDSync(value);
    }

    /**
     * Gets macro Pdf417 barcode segments count.
     */
    getPdf417MacroSegmentsCount()
    {
        return this.getJavaClass().getPdf417MacroSegmentsCountSync();
    }

    /**
     * Sets macro Pdf417 barcode segments count.
     */
    setPdf417MacroSegmentsCount(value)
    {
        this.getJavaClass().setPdf417MacroSegmentsCountSync(value);
    }

    /**
     * Gets macro Pdf417 barcode file name.
     */
    getPdf417MacroFileName()
    {
        return this.getJavaClass().getPdf417MacroFileNameSync();
    }

    /**
     * Sets macro Pdf417 barcode file name.
     */
    setPdf417MacroFileName(value)
    {
        this.getJavaClass().setPdf417MacroFileNameSync(value);
    }

    /**
     * Gets macro Pdf417 barcode time stamp.
     */
    getPdf417MacroTimeStamp()
    {
        return new Date(this.getJavaClass().getPdf417MacroTimeStampSync() * 1000);
    }

    /**
     * Sets macro Pdf417 barcode time stamp.
     */
    setPdf417MacroTimeStamp(value)
    {
        this.getJavaClass().setPdf417MacroTimeStampSync((value.getTime() / 1000).toString());
    }

    /**
     * Gets macro Pdf417 barcode sender name.
     */
    getPdf417MacroSender()
    {
        return this.getJavaClass().getPdf417MacroSenderSync();
    }

    /**
     * Sets macro Pdf417 barcode sender name.
     */
    setPdf417MacroSender(value)
    {
        this.getJavaClass().setPdf417MacroSenderSync(value);
    }

    /**
     * Gets macro Pdf417 barcode addressee name.
     */
    getPdf417MacroAddressee()
    {
        return this.getJavaClass().getPdf417MacroAddresseeSync();
    }

    /**
     * Sets macro Pdf417 barcode addressee name.
     */
    setPdf417MacroAddressee(value)
    {
        this.getJavaClass().setPdf417MacroAddresseeSync(value);
    }

    /**
     * Gets or sets macro Pdf417 file size.<br>
     * @return The file size field contains the size in bytes of the entire source file.
     */
    getPdf417MacroFileSize()
    {
        return this.getJavaClass().getPdf417MacroFileSizeSync();
    }

    /**
     * Gets or sets macro Pdf417 file size.<br>
     * @param value The file size field contains the size in bytes of the entire source file.
     */
    setPdf417MacroFileSize(value)
    {
        this.getJavaClass().setPdf417MacroFileSizeSync(value);
    }

    /**
     *  Gets macro Pdf417 barcode checksum.<br>
     * @return The checksum field contains the value of the 16-bit (2 bytes) CRC checksum using the CCITT-16 polynomial.
     */
    getPdf417MacroChecksum()
    {
        return this.getJavaClass().getPdf417MacroChecksumSync();
    }

    /**
     *  Sets macro Pdf417 barcode checksum.<br>
     * @param value The checksum field contains the value of the 16-bit (2 bytes) CRC checksum using the CCITT-16 polynomial.
     */
    setPdf417MacroChecksum(value)
    {
        this.getJavaClass().setPdf417MacroChecksumSync(value);
    }

    /**
     * Gets the encoding of codetext.<br>
     * Default value: UTF-8
     */
    getCodeTextEncoding()
    {
        return this.getJavaClass().getCodeTextEncodingSync();
    }

    /**
     * Sets the encoding of codetext.<br>
     * Default value: UTF-8
     */
    setCodeTextEncoding(value)
    {
        this.getJavaClass().setCodeTextEncodingSync(value);
    }

    /**
     * Extended Channel Interpretation Identifiers. It is used to tell the barcode reader details<br>
     * about the used references for encoding the data in the symbol.<br>
     * Current implementation consists all well known charset encodings.
     */
    getPdf417ECIEncoding()
    {
        return this.getJavaClass().getPdf417ECIEncodingSync();
    }

    /**
     * Extended Channel Interpretation Identifiers. It is used to tell the barcode reader details<br>
     * about the used references for encoding the data in the symbol.<br>
     * Current implementation consists all well known charset encodings.
     */
    setPdf417ECIEncoding(value)
    {
        this.getJavaClass().setPdf417ECIEncodingSync(value);
    }

    /**
     * Extended Channel Interpretation Identifiers. Applies for Macro PDF417 text fields.
     */
    getPdf417MacroECIEncoding()
    {
        return this.getJavaClass().getPdf417MacroECIEncodingSync();
    }

    /**
     * Extended Channel Interpretation Identifiers. Applies for Macro PDF417 text fields.
     */
    setPdf417MacroECIEncoding(value)
    {
        this.getJavaClass().setPdf417MacroECIEncodingSync(value);
    }

    /**
     * Used to instruct the reader to interpret the data contained within the symbol<br>
     * as programming for reader initialization<br>
     * @return boolean value
     */
    isReaderInitialization()
    {
        return this.getJavaClass().isReaderInitializationSync();
    }

    /**
     * Used to instruct the reader to interpret the data contained within the symbol<br>
     * as programming for reader initialization<br>
     * @param value
     */
    setReaderInitialization(value)
    {
        this.getJavaClass().setReaderInitializationSync(value);
    }

    /**
     *  Function codeword for Code 128 emulation. Applied for MicroPDF417 only.  Ignored for PDF417 and MacroPDF417 barcodes.
     */
    getCode128Emulation()
    {
        return this.getJavaClass().getCode128EmulationSync();
    }

    /**
     *  Function codeword for Code 128 emulation. Applied for MicroPDF417 only.  Ignored for PDF417 and MacroPDF417 barcodes.
     */
    setCode128Emulation(value)
    {
        this.getJavaClass().setCode128EmulationSync(value);
    }

    /**
     * Returns a human-readable string representation of this Pdf417Parameters.<br>
     * @return A string that represents this Pdf417Parameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Supplement parameters. Used for Interleaved2of5, Standard2of5, EAN13, EAN8, UPCA, UPCE, ISBN, ISSN, ISMN.
 */
class SupplementParameters extends joint.BaseJavaClass
{

    _space;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this._space = new Unit(this.getJavaClass().getSupplementSpaceSync());
    }

    /**
     * Supplement data following BarCode.
     */
    getSupplementData()
    {
        return this.getJavaClass().getSupplementDataSync();
    }

    /**
     * Supplement data following BarCode.
     */
    setSupplementData(value)
    {
        this.getJavaClass().setSupplementDataSync(value);
    }

    /**
     * Space between main the BarCode and supplement BarCode in Unit value.<br>
     * @exception IllegalArgumentException<br>
     * The Space parameter value is less than 0.
     */
    getSupplementSpace()
    {
        return this._space;
    }

    /**
     * Returns a human-readable string representation of this SupplementParameters.<br>
     * @return A string that represents this SupplementParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * MaxiCode parameters.
 */
class MaxiCodeParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Gets a MaxiCode encode mode.
     */
    getMaxiCodeEncodeMode()
    {
        return this.getJavaClass().getMaxiCodeEncodeModeSync();
    }

    /**
     * Sets a MaxiCode encode mode.
     */
    setMaxiCodeEncodeMode(value)
    {
        this.getJavaClass().setMaxiCodeEncodeModeSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Returns a human-readable string representation of this MaxiCodeParameters.<br>
     * @return A string that represents this MaxiCodeParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Aztec parameters.
 */
class AztecParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Level of error correction of Aztec types of barcode.<br>
     * Value should between 10 to 95.
     */
    getAztecErrorLevel()
    {
        return this.getJavaClass().getAztecErrorLevelSync();
    }

    /**
     * Level of error correction of Aztec types of barcode.<br>
     * Value should between 10 to 95.
     */
    setAztecErrorLevel(value)
    {
        this.getJavaClass().setAztecErrorLevelSync(value);
    }

    /**
     * Gets or sets a Aztec Symbol mode.<br>
     * Default value: AztecSymbolMode.AUTO.
     */
    getAztecSymbolMode()
    {
        return this.getJavaClass().getAztecSymbolModeSync();
    }

    /**
     * Gets or sets a Aztec Symbol mode.<br>
     * Default value: AztecSymbolMode.AUTO.
     */
    setAztecSymbolMode(value)
    {
        this.getJavaClass().setAztecSymbolModeSync(value);
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    getAspectRatio()
    {
        return this.getJavaClass().getAspectRatioSync();
    }

    /**
     * Height/Width ratio of 2D BarCode module.
     */
    setAspectRatio(value)
    {
        this.getJavaClass().setAspectRatioSync(java.newFloat(value));
    }

    /**
     * Gets the encoding of codetext.<br>
     * Default value: UTF-8
     */
    getCodeTextEncoding()
    {
        return this.getJavaClass().getCodeTextEncodingSync();
    }

    /**
     * Sets the encoding of codetext.<br>
     * Default value: UTF-8
     */
    setCodeTextEncoding(value)
    {
        this.getJavaClass().setCodeTextEncodingSync(value);
    }

    /**
     * Returns a human-readable string representation of this AztecParameters.<br>
     * @return string that represents this  AztecParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Codabar parameters.
 */
class CodabarParameters extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
    }

    /**
     * Get the checksum algorithm for Codabar barcodes.<br>
     * Default value: CodabarChecksumMode.MOD_16.<br>
     * To enable checksum calculation set value EnableChecksum.YES to property EnableChecksum.<br>
     * See CodabarChecksumMode.
     */
    getCodabarChecksumMode()
    {
        return this.getJavaClass().getCodabarChecksumModeSync();
    }

    /**
     * Set the checksum algorithm for Codabar barcodes.<br>
     * Default value: CodabarChecksumMode.MOD_16.<br>
     * To enable checksum calculation set value EnableChecksum.YES to property EnableChecksum.<br>
     * See CodabarChecksumMode.
     */
    setCodabarChecksumMode(value)
    {
        this.getJavaClass().setCodabarChecksumModeSync(value);
    }

    /**
     * Start symbol (character) of Codabar symbology.<br>
     * Default value: CodabarSymbol.A
     */
    getCodabarStartSymbol()
    {
        return this.getJavaClass().getCodabarStartSymbolSync();
    }

    /**
     * Start symbol (character) of Codabar symbology.<br>
     * Default value: CodabarSymbol.A
     */
    setCodabarStartSymbol(value)
    {
        this.getJavaClass().setCodabarStartSymbolSync(value);
    }

    /**
     * Stop symbol (character) of Codabar symbology.<br>
     * Default value: CodabarSymbol.A
     */
    getCodabarStopSymbol()
    {
        return this.getJavaClass().getCodabarStopSymbolSync();
    }

    /**
     * Stop symbol (character) of Codabar symbology.<br>
     * Default value: CodabarSymbol.A
     */
    setCodabarStopSymbol(value)
    {
        this.getJavaClass().setCodabarStopSymbolSync(value);
    }

    /**
     * Returns a human-readable string representation of this CodabarParameters.<br>
     * @return A string that represents this CodabarParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 * Coupon parameters. Used for UpcaGs1DatabarCoupon, UpcaGs1Code128Coupon.
 */
class CouponParameters extends joint.BaseJavaClass
{

    _space;

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    init()
    {
        this._space = new Unit(this.getJavaClass().getSupplementSpaceSync());
    }


    /**
     * Space between main the BarCode and supplement BarCode in Unit value.<br>
     * @exception IllegalArgumentException<br>
     * The Space parameter value is less than 0.
     */
    getSupplementSpace()
    {
        return this._space;
    }

    /**
     * Space between main the BarCode and supplement BarCode in Unit value.<br>
     * @exception IllegalArgumentException<br>
     * The Space parameter value is less than 0.
     */
    setSupplementSpace(value)
    {
        this.getJavaClass().setSupplementSpaceSync(value.getJavaClass());
        this._space = value;
    }

    /**
     * Returns a human-readable string representation of this CouponParameters.<br>
     * @return A string that represents this CouponParameters.
     */
    toString()
    {
        return this.getJavaClass().toStringSync();
    }
}

/**
 *  Defines a particular format for text, including font face, size, and style attributes<br>
 *  where size in Unit value property.<br>
 *  @example
 *  //This sample shows how to create and save a BarCode image.
 *   let generator = new BarcodeGenerator(EncodeTypes.CODE_128);
 *   generator.getParameters().getCaptionAbove().setText("CAPTION ABOOVE");
 *   generator.getParameters().getCaptionAbove().setVisible(true);
 *   generator.getParameters().getCaptionAbove().getFont().setStyle(FontStyle.ITALIC);
 *   generator.getParameters().getCaptionAbove().getFont().getSize().setPoint(25);
 */
class FontUnit extends joint.BaseJavaClass
{
    _size;

    constructor(source)
    {
        super(FontUnit.initFontUnit(source));
        this.init();
    }

    static initFontUnit(source)
    {
        if (source instanceof FontUnit)
        {
            return source.getJavaClass();
        }
        return source;
    }

    init()
    {
        this._size = new Unit(this.getJavaClass().getSizeSync());
    }

    /**
     * Gets the face name of this Font.
     */
    getFamilyName()
    {
        return this.getJavaClass().getFamilyNameSync();
    }

    /**
     * Sets the face name of this Font.
     */
    setFamilyName(value)
    {
        this.getJavaClass().setFamilyNameSync(value);
    }

    /**
     * Gets style information for this FontUnit.
     */
    getStyle()
    {
        return this.getJavaClass().getStyleSync();
    }

    /**
     * Sets style information for this FontUnit.
     */
    setStyle(value)
    {
        if (!("number" === typeof value))
        {
            value = parseInt(value, 10);
        }
        this.getJavaClass().setStyleSync(value);
    }

    /**
     * Gets size of this FontUnit in Unit value.<br>
     * @exception IllegalArgumentException<br>
     * The Size parameter value is less than or equal to 0.
     */
    getSize()
    {
        return this._size;
    }
}

/**
 * <p>
 * Helper class for automatic codetext generation of the Extended Codetext Mode
 * </p>
 */
class ExtCodetextBuilder extends joint.BaseJavaClass
{

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    /**
     * <p>
     * Clears extended codetext items
     * </p>
     */
    clear()
    {
        this.getJavaClass().clearSync();
    }

    /**
     * <p>
     * Adds plain codetext to the extended codetext items
     * </p>
     *
     * @param codetext Codetext in unicode to add as extended codetext item
     */
    addPlainCodetext(codetext)
    {
        this.getJavaClass().addPlainCodetextSync(codetext);
    }

    /**
     * <p>
     * Adds codetext with Extended Channel Identifier
     * </p>
     *
     * @param ECIEncoding Extended Channel Identifier
     * @param codetext    Codetext in unicode to add as extended codetext item with Extended Channel Identifier
     */
    addECICodetext(ECIEncoding, codetext)
    {
        this.getJavaClass().addECICodetextSync(ECIEncoding, codetext);
    }

    /**
     * <p>
     * Generate extended codetext from generation items list
     * </p>
     *
     * @return Return string of extended codetext
     */
    getExtendedCodetext()
    {
        return this.getJavaClass().getExtendedCodetextSync();
    }

}

/**
 * <p>Extended codetext generator for 2D QR barcodes for ExtendedCodetext Mode of QREncodeMode</p>
 * <p>Use Display2DText property of BarCodeBuilder to set visible text to removing managing characters.</p>
 * @example
 *  //Example how to generate FNC1 first position for Extended Mode
 *  //create codetext
 *  QrExtCodetextBuilder lTextBuilder = new QrExtCodetextBuilder();
 *  lTextBuilder.addFNC1FirstPosition();
 *  lTextBuilder.addPlainCodetext("000%89%%0");
 *  lTextBuilder.addFNC1GroupSeparator();
 *  lTextBuilder.addPlainCodetext("12345&lt;FNC1&gt;");
 *  //generate codetext
 *  String lCodetext = lTextBuilder.getExtendedCodetext();
 *
 * @example
 * //Example how to generate FNC1 second position for Extended Mode
 *  //create codetext
 *  QrExtCodetextBuilder lTextBuilder = new QrExtCodetextBuilder();
 * lTextBuilder.addFNC1SecondPosition("12");
 * lTextBuilder.addPlainCodetext("TRUE3456");
 *  //generate codetext
 * String lCodetext = lTextBuilder.getExtendedCodetext();
 *
 *  @example
 * //Example how to generate multi ECI mode for Extended Mode
 *  //create codetext
 * QrExtCodetextBuilder lTextBuilder = new QrExtCodetextBuilder();
 * lTextBuilder.addECICodetext(ECIEncodings.Win1251, "Will");
 * lTextBuilder.addECICodetext(ECIEncodings.UTF8, "Right");
 * lTextBuilder.addECICodetext(ECIEncodings.UTF16BE, "Power");
 * lTextBuilder.addPlainCodetext("t\\e\\\\st");
 *  //generate codetext
 *  String lCodetext = lTextBuilder.getExtendedCodetext();
 *
 *
 */
class QrExtCodetextBuilder extends ExtCodetextBuilder
{
    static get javaClassName()
    {
        return "com.aspose.mw.barcode.MwQrExtCodetextBuilder";
    }

    constructor()
    {
        super(new java.import(QrExtCodetextBuilder.javaClassName)());
        this.init();
    }


    init()
    {
    }

    /**
     * <p>
     * Adds FNC1 in first position to the extended codetext items
     * </p>
     */
    addFNC1FirstPosition()
    {
        this.getJavaClass().addFNC1FirstPositionSync();
    }

    /**
     * <p>
     * Adds FNC1 in second position to the extended codetext items
     * </p>
     *
     * @param codetext Value of the FNC1 in the second position
     */
    addFNC1SecondPosition(codetext)
    {
        this.getJavaClass().addFNC1SecondPositionSync(codetext);
    }

    /**
     * <p>
     * Adds Group Separator (GS - '\\u001D') to the extended codetext items
     * </p>
     */
    addFNC1GroupSeparator()
    {
        this.getJavaClass().addFNC1GroupSeparatorSync();
    }

    /**
     * <p>
     * Generates Extended codetext from the extended codetext list.
     * </p>
     *
     * @return Extended codetext as string
     */
    getExtendedCodetext()
    {
        return this.getJavaClass().getExtendedCodetextSync();
    }

}

/**
 * QR structured append parameters.
 */
class QrStructuredAppendParameters extends joint.BaseJavaClass
{
    init()
    {
        // TODO: Implement init() method.
    }

    constructor(javaClass)
    {
        super(javaClass);
        this.init();
    }

    /**
     *  Gets the QR structured append mode parity data.
     */
    getParityByte()
    {
        return this.getJavaClass().getParityByteSync();
    }

    /**
     *  Sets the QR structured append mode parity data.
     */
    setParityByte(value)
    {
        this.getJavaClass().setParityByteSync(value);
    }

    /**
     * Gets the index of the QR structured append mode barcode. Index starts from 0.
     */
    getSequenceIndicator()
    {
        return this.getJavaClass().getSequenceIndicatorSync();
    }

    /**
     * Sets the index of the QR structured append mode barcode. Index starts from 0.
     */
    setSequenceIndicator(value)
    {
        this.getJavaClass().setSequenceIndicatorSync(value);
    }

    /**
     * Gets the QR structured append mode barcodes quantity. Max value is 16.
     */
    getTotalCount()
    {
        return this.getJavaClass().getTotalCountSync();
    }

    /**
     * Sets the QR structured append mode barcodes quantity. Max value is 16.
     */
    setTotalCount(value)
    {
        this.getJavaClass().setTotalCountSync(value);
    }
}

/**
 * BarcodeClassifications EncodeTypes classification
 * @enum
 */
BarcodeClassifications =
    {
        /**
         * Unspecified classification
         */
        NONE: 0,

        /**
         * Specifies 1D-barcode
         */
        TYPE_1D: 1,

        /**
         * Specifies 2D-barcode
         */
        TYPE_2D: 2,

        /**
         * Specifies POSTAL-barcode
         */
        POSTAL: 3,

        /**
         * Specifies DataBar-barcode
         */
        DATABAR: 4,

        /**
         * Specifies COUPON-barcode
         */
        COUPON: 5
    };

/**
 * FontStyle classification
 * @enum
 */
FontStyle =
    {
        BOLD: 1,
        ITALIC: 2,
        REGULAR: 0,
        STRIKEOUT: 8,
        UNDERLINE: 4
    };

/**
 * Specifies the start or stop symbol of the Codabar barcode specification.
 * @enum
 */
CodabarSymbol =
    {

        /**
         * Specifies character A as the start or stop symbol of the Codabar barcode specification.
         */
        A: 65,
        /**
         * Specifies character B as the start or stop symbol of the Codabar barcode specification.
         */
        B: 66,
        /**
         * Specifies character C as the start or stop symbol of the Codabar barcode specification.
         */
        C: 67,
        /**
         * Specifies character D as the start or stop symbol of the Codabar barcode specification.
         */
        D: 68,
    };

/**
 * DataMatrix encoder's encoding mode, default to AUTO
 * @enum
 */
DataMatrixEncodeMode =
    {

        /**
         * Automatically pick up the best encode mode for datamatrix encoding
         */
        AUTO: 0,
        /**
         * Encodes one alphanumeric or two numeric characters per byte
         */
        ASCII: 1,
        /**
         * Encode 8 bit values
         */
        FULL: 6,
        /**
         * Encode with the encoding specified in BarCodeGenerator.CodeTextEncoding
         */
        CUSTOM: 7,


        /**
         * Uses C40 encoding. Encodes Upper-case alphanumeric, Lower case and special characters
         */
        C40: 8,

        /**
         * UUses TEXT encoding. Encodes Lower-case alphanumeric, Upper case and special characters
         */
        TEXT: 9,

        /**
         * Uses EDIFACT encoding. Uses six bits per character, encodes digits, upper-case letters, and many punctuation marks, but has no support for lower-case letters.
         */
        EDIFACT: 10,

        /**
         * Uses ANSI X12 encoding.
         */
        ANSIX12: 11,

        /**
         * ExtendedCodetext mode allows to manually switch encodation schemes in codetext.
         * Allowed encodation schemes are: EDIFACT, ANSIX12, ASCII, C40, Text, Auto.
         * Extended codetext example: @"\ansix12:ANSIX12TEXT\ascii:backslash must be \\ doubled\edifact:EdifactEncodedText"
         * All backslashes (\) must be doubled in text.
         *
         * @example
         * //This sample shows how to do codetext in Extended Mode.
         *
         * $generator = new BarcodeGenerator(EncodeTypes.DATA_MATRIX);
         * $generator->setCodeText("\\ansix12:ANSIX12TEXT\\ascii:backslash must be \\\\ doubled\\edifact:EdifactEncodedText");
         * $generator->getParameters()->getBarcode()->getDataMatrix().setDataMatrixEncodeMode(DataMatrixEncodeMode.EXTENDED_CODETEXT);
         * $generator->getParameters()->getBarcode()->getCodeTextParameters().setTwoDDisplayText("My Text");
         * $generator->save("test.png");
         */
        EXTENDED_CODETEXT: 12
    };

/**
 * Specifies the style of dashed border lines.
 * @enum
 */
BorderDashStyle =
    {
        /**
         * Specifies a solid line.
         */
        SOLID: 0, //DashStyle.Solid
        /**
         * Specifies a line consisting of dashes.
         */
        DASH: 1, // DashStyle.Dash
        /**
         * Specifies a line consisting of dots.
         */
        DOT: 2, //(DashStyle.Dot

        /**
         * Specifies a line consisting of a repeating pattern of dash-dot.
         */
        DASH_DOT: 3, //DashStyle.DashDot
        /**
         * Specifies a line consisting of a repeating pattern of dash-dot-dot.
         */
        DASH_DOT_DOT: 4, //DashStyle.DashDotDot
    };

/**
 * ITF14 barcode's border type
 * @enum
 */
ITF14BorderType =
    {
        /**
         * NO border enclosing the barcode
         */
        NONE: 0,
        /**
         * FRAME enclosing the barcode
         */
        FRAME: 1,
        /**
         * Tow horizontal bars enclosing the barcode
         */
        BAR: 2,
        /**
         * FRAME enclosing the barcode
         */
        FRAME_OUT: 3,
        /**
         * Tow horizontal bars enclosing the barcode
         */
        BAR_OUT: 4,
    };

/**
 * Encoding mode for QR barcodes. It is recommended to Use AUTO with CodeTextEncoding = Encoding.UTF8 for latin symbols or digits and UTF_8_BOM for unicode symbols.
 *  @example
 *     //Example how to use ECI encoding
 *     BarcodeGenerator generator = new BarcodeGenerator(EncodeTypes.QR);
 *     generator.setCodeText("12345TEXT");
 *     generator.getParameters().getBarcode().getQR().setQrEncodeMode(QREncodeMode.ECI_ENCODING);
 *     generator.getParameters().getBarcode().getQR().setQrEncodeType(QREncodeType.FORCE_QR);
 *     generator.getParameters().getBarcode().getQR().setQrECIEncoding(ECIEncodings.UTF8);
 *     generator.save("test.png");
 *
 * @example
 *      //Example how to use FNC1 first position in Extended Mode
 *      QrExtCodetextBuilder textBuilder = new QrExtCodetextBuilder();
 *      textBuilder.addPlainCodetext("000%89%%0");
 *      textBuilder.addFNC1GroupSeparator();
 *      textBuilder.addPlainCodetext("12345&lt;FNC1&gt;");
 *      //generate barcode
 *      BarcodeGenerator generator = new BarcodeGenerator(EncodeTypes.QR);
 *      generator.setCodeText(textBuilder.getExtendedCodetext());
 *      generator.getParameters().getBarcode().getQR().setQrEncodeMode(QREncodeMode.EXTENDED_CODETEXT);
 *      generator.getParameters().getBarcode().getCodeTextParameters().setTwoDDisplayText("My Text");
 *      generator.save("d:/test.png");
 *
 * @example
 *   // This sample shows how to use FNC1 second position in Extended Mode.
 *    //create codetext
 *    QrExtCodetextBuilder textBuilder = new QrExtCodetextBuilder();
 *    textBuilder.addFNC1SecondPosition("12");
 *    textBuilder.addPlainCodetext("TRUE3456");
 *    //generate barcode
 *    BarcodeGenerator generator = new BarcodeGenerator(EncodeTypes.QR);
 *    generator.setCodeText(textBuilder.getExtendedCodetext());
 *    generator.getParameters().getBarcode().getCodeTextParameters().setTwoDDisplayText("My Text");
 *    generator.save("d:/test.png");
 *
 *    @example
 *    //This sample shows how to use multi ECI mode in Extended Mode.
 *   //create codetext
 *   QrExtCodetextBuilder textBuilder = new QrExtCodetextBuilder();
 *   textBuilder.addECICodetext(ECIEncodings.Win1251, "Will");
 *   textBuilder.addECICodetext(ECIEncodings.UTF8, "Right");
 *   textBuilder.addECICodetext(ECIEncodings.UTF16BE, "Power");
 *   textBuilder.addPlainCodetext("t\e\\st");
 *   //generate barcode
 *   BarcodeGenerator generator = new BarcodeGenerator(EncodeTypes.QR);
 *   generator.setCodeText(textBuilder.getExtendedCodetext());
 *   generator.getParameters().getBarcode().getQR().setQrEncodeMode(QREncodeMode.EXTENDED_CODETEXT);
 *   generator.getParameters().getBarcode().getCodeTextParameters().setTwoDDisplayText("My Text");
 *   generator.save("d:/test.png");
 * @enum
 */
QREncodeMode =
    {
        /**
         * Encode codetext as is non-unicode charset. <br>
         * If there is any unicode character, <br>
         * the codetext will be encoded with value which is set in CodeTextEncoding.
         */
        AUTO: 0,
        /**
         * Encode codetext as plain bytes. If it detects any unicode character, the character will be encoded as two bytes, lower byte first.
         */
        BYTES: 1,
        //https://en.wikipedia.org/wiki/Byte_order_mark
        /**
         * Encode codetext with UTF8 encoding with first ByteOfMark character.
         */
        UTF_8_BOM: 2,
        /**
         * Encode codetext with UTF8 encoding with first ByteOfMark character. It can be problems with some barcode scaners.
         */
        UTF_16_BEBOM: 3,

        /**
         * Encode codetext with value set in the ECI_ENCODING property. It can be problems with some old (pre 2006) barcode scaners.
         */
        ECI_ENCODING: 4,

        /**
         * <p>
         * <p>Extended Channel mode which supports FNC1 first position, FNC1 second position and multi ECI modes.</p>
         * <p>It is better to use QrExtCodetextBuilder for extended codetext generation.</p>
         * <p>Use Display2DText property to set visible text to removing managing characters.</p>
         * <p>Encoding Principles:</p>
         * <p>All symbols "\" must be doubled "\\" in the codetext.</p>
         * <p>FNC1 in first position is set in codetext as as "&lt;FNC1&gt;"</p>
         * <p>FNC1 in second position is set in codetext as as "&lt;FNC1(value)&gt;". The value must be single symbols (a-z, A-Z) or digits from 0 to 99.</p>
         * <p>Group Separator for FNC1 modes is set as 0x1D character '\\u001D' </p>
         * <p> If you need to insert "&lt;FNC1&gt;" string into barcode write it as "&lt;\FNC1&gt;" </p>
         * <p>ECI identifiers are set as single slash and six digits identifier "\000026" - UTF8 ECI identifier</p>
         * <p>TO disable current ECI mode and convert to default JIS8 mode zero mode ECI indetifier is set. "\000000"</p>
         * <p>All unicode characters after ECI identifier are automatically encoded into correct character codeset.</p>
         * </p>
         */
        EXTENDED_CODETEXT: 5

    };


/**
 * Specify the type of the ECC to encode.
 * @enum
 */
DataMatrixEccType =
    {
        /**
         * Specifies that encoded Ecc type is defined by default Reed-Solomon error correction or ECC 200.
         */
        ECC_AUTO: 0,
        /**
         * Specifies that encoded Ecc type is defined ECC 000.
         */
        ECC_000: 1,
        /**
         * Specifies that encoded Ecc type is defined ECC 050.
         */
        ECC_050: 2,
        /**
         * Specifies that encoded Ecc type is defined ECC 080.
         */
        ECC_080: 3,
        /**
         * Specifies that encoded Ecc type is defined ECC 100.
         */
        ECC_100: 4,
        /**
         * Specifies that encoded Ecc type is defined ECC 140.
         */
        ECC_140: 5,
        /**
         * Specifies that encoded Ecc type is defined ECC 200. Recommended to use.
         */
        ECC_200: 6
    };

/**
 * Version of QR Code.
 * From Version1 to Version40 for QR code and from M1 to M4 for MicroQr.
 * @enum
 */
QRVersion =
    {
        /**
         * Specifies to automatically pick up the best version for QR.
         * This is default value.
         */
        AUTO: 0,

        /**
         * Specifies version 1 with 21 x 21 modules.
         */
        VERSION_01: 1,

        /**
         * Specifies version 2 with 25 x 25 modules.
         */
        VERSION_02: 2,

        /**
         * Specifies version 3 with 29 x 29 modules.
         */
        VERSION_03: 3,

        /**
         * Specifies version 4 with 33 x 33 modules.
         */
        VERSION_04: 4,

        /**
         * Specifies version 5 with 37 x 37 modules.
         */
        VERSION_05: 5,

        /**
         * Specifies version 6 with 41 x 41 modules.
         */
        VERSION_06: 6,

        /**
         * Specifies version 7 with 45 x 45 modules.
         */
        VERSION_07: 7,

        /**
         * Specifies version 8 with 49 x 49 modules.
         */
        VERSION_08: 8,

        /**
         * Specifies version 9 with 53 x 53 modules.
         */
        VERSION_09: 9,


        /**
         * Specifies version 10 with 57 x 57 modules.
         */
        VERSION_10: 10,

        /**
         * Specifies version 11 with 61 x 61 modules.
         */
        VERSION_11: 11,

        /**
         * Specifies version 12 with 65 x 65 modules.
         */
        VERSION_12: 12,

        /**
         * Specifies version 13 with 69 x 69 modules.
         */
        VERSION_13: 13,

        /**
         * Specifies version 14 with 73 x 73 modules.
         */
        VERSION_14: 14,

        /**
         * Specifies version 15 with 77 x 77 modules.
         */
        VERSION_15: 15,

        /**
         * Specifies version 16 with 81 x 81 modules.
         */
        VERSION_16: 16,

        /**
         * Specifies version 17 with 85 x 85 modules.
         */
        VERSION_17: 17,

        /**
         * Specifies version 18 with 89 x 89 modules.
         */
        VERSION_18: 18,

        /**
         * Specifies version 19 with 93 x 93 modules.
         */
        VERSION_19: 19,

        /**
         * Specifies version 20 with 97 x 97 modules.
         */
        VERSION_20: 20,

        /**
         * Specifies version 21 with 101 x 101 modules.
         */
        VERSION_21: 21,

        /**
         * Specifies version 22 with 105 x 105 modules.
         */
        VERSION_22: 22,

        /**
         * Specifies version 23 with 109 x 109 modules.
         */
        VERSION_23: 23,

        /**
         * Specifies version 24 with 113 x 113 modules.
         */
        VERSION_24: 24,

        /**
         * Specifies version 25 with 117 x 117 modules.
         */
        VERSION_25: 25,


        /**
         * Specifies version 26 with 121 x 121 modules.
         */
        VERSION_26: 26,

        /**
         * Specifies version 27 with 125 x 125 modules.
         */
        VERSION_27: 27,

        /**
         * Specifies version 28 with 129 x 129 modules.
         */
        VERSION_28: 28,

        /**
         * Specifies version 29 with 133 x 133 modules.
         */
        VERSION_29: 29,

        /**
         * Specifies version 30 with 137 x 137 modules.
         */
        VERSION_30: 30,

        /**
         * Specifies version 31 with 141 x 141 modules.
         */
        VERSION_31: 31,

        /**
         * Specifies version 32 with 145 x 145 modules.
         */
        VERSION_32: 32,

        /**
         * Specifies version 33 with 149 x 149 modules.
         */
        VERSION_33: 33,

        /**
         * Specifies version 34 with 153 x 153 modules.
         */
        VERSION_34: 34,

        /**
         * Specifies version 35 with 157 x 157 modules.
         */
        VERSION_35: 35,

        /**
         * Specifies version 36 with 161 x 161 modules.
         */
        VERSION_36: 36,

        /**
         * Specifies version 37 with 165 x 165 modules.
         */
        VERSION_37: 37,

        /**
         * Specifies version 38 with 169 x 169 modules.
         */
        VERSION_38: 38,

        /**
         * Specifies version 39 with 173 x 173 modules.
         */
        VERSION_39: 39,

        /**
         * Specifies version 40 with 177 x 177 modules.
         */
        VERSION_40: 40,

        /**
         * Specifies version M1 for Micro QR with 11 x 11 modules.
         */
        VERSION_M1: 101,

        /**
         * Specifies version M2 for Micro QR with 13 x 13 modules.
         */
        VERSION_M2: 102,

        /**
         * Specifies version M3 for Micro QR with 15 x 15 modules.
         */
        VERSION_M3: 103,

        /**
         * Specifies version M4 for Micro QR with 17 x 17 modules.
         */
        VERSION_M4: 104,
    };

/**
 * Specifies the Aztec symbol mode.
 * @example
 *  let generator = new BarcodeGenerator(EncodeTypes.AZTEC);
 *  generator.setCodeText("125");
 *  generator.getParameters().getBarcode().getAztec().setAztecSymbolMode(AztecSymbolMode.RUNE);
 *  generator.save("test.png", BarCodeImageFormat.PNG);
 * @enum
 */
AztecSymbolMode =
    {
        /**
         * Specifies to automatically pick up the best symbol (COMPACT or FULL-range) for Aztec.
         * This is default value.
         * @enum
         */
        AUTO: 0,
        /**
         * Specifies the COMPACT symbol for Aztec.
         * Aztec COMPACT symbol permits only 1, 2, 3 or 4 layers.
         */
        COMPACT: 1,
        /**
         * Specifies the FULL-range symbol for Aztec.
         * Aztec FULL-range symbol permits from 1 to 32 layers.
         */
        FULL_RANGE: 2,
        /**
         * Specifies the RUNE symbol for Aztec.
         * Aztec Runes are a series of small but distinct machine-readable marks. It permits only number value from 0 to 255.
         */
        RUNE: 3
    };

/**
 * pdf417 barcode's error correction level, from level 0 to level 9, level 0 means no error correction, level 9 means best error correction
 * @enum
 */
Pdf417ErrorLevel =
    {

        /**
         * level = 0.
         */
        LEVEL_0: 0,
        /**
         * level = 1.
         */
        LEVEL_1: 1,
        /**
         * level = 2.
         */
        LEVEL_2: 2,
        /**
         * level = 3.
         */
        LEVEL_3: 3,
        /**
         * level = 4.
         */
        LEVEL_4: 4,
        /**
         * level = 5.
         */
        LEVEL_5: 5,
        /**
         * level = 6.
         */
        LEVEL_6: 6,
        /**
         * level = 7.
         */
        LEVEL_7: 7,
        /**
         * level = 8.
         */
        LEVEL_8: 8
    };


/**
 * Pdf417 barcode's compation mode
 * @enum
 */
Pdf417CompactionMode =
    {
        /**
         * auto detect compation mode
         */
        AUTO: 0,
        /**
         * text compaction
         */
        TEXT: 1,
        /**
         * numeric compaction mode
         */
        NUMERIC: 2,
        /**
         * binary compaction mode
         */
        BINARY: 3
    };

/**
 * Level of Reed-Solomon error correction. From low to high: LEVEL_L, LEVEL_M, LEVEL_Q, LEVEL_H.
 * @enum
 */
QRErrorLevel =
    {
        /**
         * Allows recovery of 7% of the code text
         */
        LEVEL_L: 0,
        /**
         * Allows recovery of 15% of the code text
         */
        LEVEL_M: 1,
        /**
         * Allows recovery of 25% of the code text
         */
        LEVEL_Q: 2,
        /**
         * Allows recovery of 30% of the code text
         */
        LEVEL_H: 3
    };


/**
 * QR / MicroQR selector mode. Select FORCE_QR for standard QR symbols, AUTO for MicroQR.
 * FORCE_MICRO_QR is used for strongly MicroQR symbol generation if it is possible.
 * @enum
 */
QREncodeType =
    {
        /**
         * Mode starts barcode version negotiation from MicroQR V1
         */
        AUTO: 0,
        /**
         * Mode starts barcode version negotiation from QR V1
         */
        FORCE_QR: 1,
        /**
         * Mode starts barcode version negotiation from from MicroQR V1 to V4. If data cannot be encoded into MicroQR, exception is thrown.
         */
        FORCE_MICRO_QR: 2
    };

/**
 * Specifies the checksum algorithm for Codabar
 * @enum
 */
CodabarChecksumMode =
    {

        /**
         * Specifies Mod 10 algorithm for Codabar.
         */
        MOD_10: 0,

        /**
         * Specifies Mod 16 algorithm for Codabar (recomended AIIM).
         */
        MOD_16: 1
    };

/**
 * Codetext location
 * @enum
 */
CodeLocation =
    {
        /**
         * Codetext below barcode.
         */
        BELOW: 0,

        /**
         * Codetext above barcode.
         */
        ABOVE: 1,

        /**
         * Hide codetext.
         */
        NONE: 2
    };


/**
 * Font size mode.
 * @enum
 */
FontMode =
    {
        /**
         * Automatically calculate Font size based on barcode size.
         */
        AUTO: 0,

        /**
         * Use Font sized defined by user.
         */
        MANUAL: 1
    };

/**
 * Text alignment.
 * @enum
 */
TextAlignment =
    {
        /**
         * Left position.
         */
        LEFT: 0,

        /**
         * Center position.
         */
        CENTER: 1,

        /**
         * Right position.
         */
        RIGHT: 2
    };

/**
 * Specifies the different types of automatic sizing modes.<br>
 * Default value is AutoSizeMode.NONE.
 *  @example
 *  //This sample shows how to create and save a BarCode image:
 *  let generator = new BarcodeGenerator(EncodeTypes.DATA_MATRIX);
 *  generator.setAutoSizeMode(AutoSizeMode.NEAREST);
 *  generator.getBarCodeWidth().setMillimeters(50);
 *  generator.getBarCodeHeight().setInches(1.3f);
 *  generator.save("test.png");
 *
 *  @enum
 */
AutoSizeMode =
    {
        /**
         * Automatic resizing is disabled. Default value.
         */
        NONE: 0,  //or CUSTOM, or DEFAULT

        /**
         * Barcode resizes to nearest lowest possible size
         * which are specified by BarCodeWidth and BarCodeHeight properties.
         */
        NEAREST: 1,

        /**
         *  Resizes barcode to specified size with little scaling
         *  but it can be little damaged in some cases
         *  because using interpolation for scaling.
         *  Size can be specified by BarcodeGenerator.BarCodeWidth
         *  and BarcodeGenerator.BarCodeHeight properties.
         *  This sample shows how to create and save a BarCode image in Scale mode.
         *      let generator = new BarcodeGenerator( EncodeTypes.DATA_MATRIX);
         *      generator.getParameters().getBarcode().setAutoSizeMode(AutoSizeMode.INTERPOLATION);
         *      generator.getParameters().getBarcode().getBarCodeWidth().setMillimeters(50);
         *      generator.getParameters().getBarcode().getBarCodeHeight().setInches(1.3);
         *      generator.save("test.png");
         */
        INTERPOLATION: 2,
    };

/**
 * Specifies the unit of measure for the given data.
 * @enum
 */
GraphicsUnit =
    {
        /**
         * Specifies the world coordinate system unit as the unit of measure.
         */
        WORLD: 0,

        /**
         * Specifies the unit of measure of the display device. Typically pixels for video displays, and 1/100 inch for printers.
         */
        DISPLAY: 1,

        /**
         *    Specifies a device pixel as the unit of measure.
         */
        PIXEL: 2,

        /**
         * Specifies a printer's point  = 1/72 inch) as the unit of measure.
         */
        POINT: 3,

        /**
         *    Specifies the inch as the unit of measure.
         */
        INCH: 4,

        /**
         * Specifies the document unit  = 1/300 inch) as the unit of measure.
         */
        DOCUMENT: 5,

        /**
         * Specifies the millimeter as the unit of measure.
         */
        MILLIMETER: 6,
    };

/**
 * Specifies the type of barcode to encode.
 * @enum
 */
EncodeTypes =
    {

        /**
         * Unspecified encode type.
         */
        NONE: -1,

        /**
         * Specifies that the data should be encoded with CODABAR barcode specification
         */
        CODABAR: 0,

        /**
         * Specifies that the data should be encoded with CODE 11 barcode specification
         */
        CODE_11: 1,

        /**
         * Specifies that the data should be encoded with Standard CODE 39 barcode specification
         */
        CODE_39_STANDARD: 2,

        /**
         * Specifies that the data should be encoded with Extended CODE 39 barcode specification
         */
        CODE_39_EXTENDED: 3,

        /**
         * Specifies that the data should be encoded with Standard CODE 93 barcode specification
         */
        CODE_93_STANDARD: 4,

        /**
         * Specifies that the data should be encoded with Extended CODE 93 barcode specification
         */
        CODE_93_EXTENDED: 5,

        /**
         * Specifies that the data should be encoded with CODE 128 barcode specification
         */
        CODE_128: 6,

        /**
         * Specifies that the data should be encoded with GS1 Code 128 barcode specification. The codetext must contains parentheses for AI.
         */
        GS_1_CODE_128: 7,

        /**
         * Specifies that the data should be encoded with EAN-8 barcode specification
         */
        EAN_8: 8,

        /**
         * Specifies that the data should be encoded with EAN-13 barcode specification
         */
        EAN_13: 9,

        /**
         * Specifies that the data should be encoded with EAN14 barcode specification
         */
        EAN_14: 10,

        /**
         * Specifies that the data should be encoded with SCC14 barcode specification
         */
        SCC_14: 11,

        /**
         * Specifies that the data should be encoded with SSCC18 barcode specification
         */
        SSCC_18: 12,

        /**
         * Specifies that the data should be encoded with UPC-A barcode specification
         */
        UPCA: 13,

        /**
         * Specifies that the data should be encoded with UPC-E barcode specification
         */
        UPCE: 14,

        /**
         * Specifies that the data should be encoded with isBN barcode specification
         */
        ISBN: 15,

        /**
         * Specifies that the data should be encoded with ISSN barcode specification
         */
        ISSN: 16,

        /**
         * Specifies that the data should be encoded with ISMN barcode specification
         */
        ISMN: 17,

        /**
         * Specifies that the data should be encoded with Standard 2 of 5 barcode specification
         */
        STANDARD_2_OF_5: 18,

        /**
         * Specifies that the data should be encoded with INTERLEAVED 2 of 5 barcode specification
         */
        INTERLEAVED_2_OF_5: 19,

        /**
         * Represents Matrix 2 of 5 BarCode
         */
        MATRIX_2_OF_5: 20,

        /**
         * Represents Italian Post 25 barcode.
         */
        ITALIAN_POST_25: 21,

        /**
         * Represents IATA 2 of 5 barcode.IATA (International Air Transport Assosiation) uses this barcode for the management of air cargo.
         */
        IATA_2_OF_5: 22,

        /**
         * Specifies that the data should be encoded with ITF14 barcode specification
         */
        ITF_14: 23,

        /**
         * Represents ITF-6  Barcode.
         */
        ITF_6: 24,

        /**
         * Specifies that the data should be encoded with MSI Plessey barcode specification
         */
        MSI: 25,

        /**
         * Represents VIN (Vehicle Identification Number) Barcode.
         */
        VIN: 26,

        /**
         * Represents Deutsch Post barcode, This EncodeType is also known as Identcode,CodeIdentcode,German Postal 2 of 5 Identcode,
         * Deutsch Post AG Identcode, Deutsch Frachtpost Identcode,  Deutsch Post AG (DHL)
         */
        DEUTSCHE_POST_IDENTCODE: 27,

        /**
         * Represents Deutsch Post Leitcode Barcode,also known as German Postal 2 of 5 Leitcode, CodeLeitcode, Leitcode, Deutsch Post AG (DHL).
         */
        DEUTSCHE_POST_LEITCODE: 28,

        /**
         * Represents OPC(Optical Product Code) Barcode,also known as , VCA Barcode VCA OPC, Vision Council of America OPC Barcode.
         */
        OPC: 29,

        /**
         * Represents PZN barcode.This EncodeType is also known as Pharmacy central number, Pharmazentralnummer
         */
        PZN: 30,

        /**
         * Represents Code 16K barcode.
         */
        CODE_16_K: 31,

        /**
         * Represents Pharmacode barcode.
         */
        PHARMACODE: 32,

        /**
         * 2D barcode symbology DataMatrix
         */
        DATA_MATRIX: 33,

        /**
         * Specifies that the data should be encoded with QR Code barcode specification
         */
        QR: 34,

        /**
         * Specifies that the data should be encoded with Aztec barcode specification
         */
        AZTEC: 35,

        /**
         * Specifies that the data should be encoded with Pdf417 barcode specification
         */
        PDF_417: 36,

        /**
         * Specifies that the data should be encoded with MacroPdf417 barcode specification
         */
        MACRO_PDF_417: 37,

        /**
         * 2D barcode symbology DataMatrix with GS1 string format
         */
        GS_1_DATA_MATRIX: 48,

        /**
         * Specifies that the data should be encoded with MicroPdf417 barcode specification
         */
        MICRO_PDF_417: 55,

        /**
         * 2D barcode symbology QR with GS1 string format
         */
        GS_1_QR: 56,

        /**
         * Specifies that the data should be encoded with MaxiCode barcode specification
         */
        MAXI_CODE: 57,

        /**
         * Specifies that the data should be encoded with DotCode barcode specification
         */
        DOT_CODE: 60,

        /**
         * Represents Australia Post Customer BarCode
         */
        AUSTRALIA_POST: 38,

        /**
         * Specifies that the data should be encoded with Postnet barcode specification
         */
        POSTNET: 39,

        /**
         * Specifies that the data should be encoded with Planet barcode specification
         */
        PLANET: 40,

        /**
         * Specifies that the data should be encoded with USPS OneCode barcode specification
         */
        ONE_CODE: 41,

        /**
         * Represents RM4SCC barcode. RM4SCC (Royal Mail 4-state Customer Code) is used for automated mail sort process in UK.
         */
        RM_4_SCC: 42,

        /**
         * Represents Royal Mail Mailmark barcode.
         */
        MAILMARK: 66,

        /**
         * Specifies that the data should be encoded with GS1 Databar omni-directional barcode specification.
         */
        DATABAR_OMNI_DIRECTIONAL: 43,

        /**
         * Specifies that the data should be encoded with GS1 Databar truncated barcode specification.
         */
        DATABAR_TRUNCATED: 44,

        /**
         * Represents GS1 DATABAR limited barcode.
         */
        DATABAR_LIMITED: 45,

        /**
         * Represents GS1 Databar expanded barcode.
         */
        DATABAR_EXPANDED: 46,

        /**
         * Represents GS1 Databar expanded stacked barcode.
         */
        DATABAR_EXPANDED_STACKED: 52,

        /**
         * Represents GS1 Databar stacked barcode.
         */
        DATABAR_STACKED: 53,

        /**
         * Represents GS1 Databar stacked omni-directional barcode.
         */
        DATABAR_STACKED_OMNI_DIRECTIONAL: 54,

        /**
         * Specifies that the data should be encoded with Singapore Post Barcode barcode specification
         */
        SINGAPORE_POST: 47,

        /**
         * Specifies that the data should be encoded with Australian Post Domestic eParcel Barcode barcode specification
         */
        AUSTRALIAN_POSTE_PARCEL: 49,

        /**
         * Specifies that the data should be encoded with Swiss Post Parcel Barcode barcode specification. Supported types: Domestic Mail, International Mail, Additional Services (new)
         */
        SWISS_POST_PARCEL: 50,

        /**
         * Represents Patch code barcode
         */
        PATCH_CODE: 51,

        /**
         * Specifies that the data should be encoded with Code32 barcode specification
         */
        CODE_32: 58,

        /**
         * Specifies that the data should be encoded with DataLogic 2 of 5 barcode specification
         */
        DATA_LOGIC_2_OF_5: 59,

        /**
         * Specifies that the data should be encoded with Dutch KIX barcode specification
         */
        DUTCH_KIX: 61,

        /**
         * Specifies that the data should be encoded with UPC coupon with GS1-128 Extended Code barcode specification.
         * An example of the input string:
         * BarCodeGenerator.setCodetext("514141100906(8102)03"),
         * where UPCA part is "514141100906", GS1Code128 part is (8102)03.
         */
        UPCA_GS_1_CODE_128_COUPON: 62,

        /**
         * Specifies that the data should be encoded with UPC coupon with GS1 DataBar addition barcode specification.
         * An example of the input string:
         * BarCodeGenerator.setCodetext("514141100906(8110)106141416543213500110000310123196000"),
         * where UPCA part is "514141100906, DATABAR part is "(8110)106141416543213500110000310123196000".
         * To change the caption, use barCodeBuilder.getCaptionAbove().setText("company prefix + offer code")",
         */
        UPCA_GS_1_DATABAR_COUPON: 63,

        /**
         * Specifies that the data should be encoded with Codablock-F barcode specification.
         */
        CODABLOCK_F: 64,

        /**
         * Specifies that the data should be encoded with GS1 Codablock-F barcode specification. The codetext must contains parentheses for AI.
         */
        GS_1_CODABLOCK_F: 65,

        /**
         * Specifies that the data should be encoded with <b>GS1 Composite Bar</b> barcode specification. The codetext must contains parentheses for AI. 1D codetext and 2D codetext must be separated with symbol '/'
         */
        GS_1_COMPOSITE_BAR: 71
    };

/*
*@enum
 */
MacroCharacter =
    {
        /**
         * None of Macro Characters are added to barcode data
         */
        NONE: 0,

        /**
         * 05 Macro craracter is added to barcode data in first position.
         * GS1 Data Identifier ISO 15434
         * Character is translated to "[)>\u001E05\u001D" as decoded data header and "\u001E\u0004" as decoded data trailer.
         *
         * //to generate autoidentified GS1 message like this "(10)123ABC(10)123ABC" in ISO 15434 format you need:
         * let generator = new BarcodeGenerator(EncodeTypes.DATA_MATRIX, "10123ABC\u001D10123ABC");
         * generator.getParameters().getBarcode().getDataMatrix().setMacroCharacters(MacroCharacter.MACRO_05);
         * let reader = new BarCodeReader(generator.generateBarCodeImage(), DecodeType.GS_1_DATA_MATRIX);
         * reader.readBarCodes().forEach(function(result, i, results)
         * {
         *     cosole.log("BarCode CodeText: " + result.getCodeText());
         * });
         */
        MACRO_05: 5,

        /**
         * 06 Macro craracter is added to barcode data in first position.
         * ASC MH10 Data Identifier ISO 15434
         * Character is translated to "[)>\u001E06\u001D" as decoded data header and "\u001E\u0004" as decoded data trailer.
         */
        MACRO_06: 6
    };

/**
 * PatchCode format. Choose PatchOnly to generate single PatchCode. Use page format to generate Patch page with PatchCodes as borders
 * @enum
 */
PatchFormat =
    {
        /**
         * Generates PatchCode only
         */
        PATCH_ONLY: 0,

        /**
         * Generates A4 format page with PatchCodes as borders and optional QR in the center
         */
        A4: 1,

        /**
         * Generates A4 landscape format page with PatchCodes as borders and optional QR in the center
         */
        A4_LANDSCAPE: 2,

        /**
         * Generates US letter format page with PatchCodes as borders and optional QR in the center
         */
        US_LETTER: 3,

        /**
         * Generates US letter landscape format page with PatchCodes as borders and optional QR in the center
         */
        US_LETTER_LANDSCAPE: 4
    };

/**
 * Extended Channel Interpretation Identifiers. It is used to tell the barcode reader details
 * about the used references for encoding the data in the symbol.
 * Current implementation consists all well known charset encodings.
 * Currently, it is used only for QR 2D barcode.
 * @example
 * let generator = new BarcodeGenerator(EncodeTypes.QR);
 * generator.setCodeText("12345TEXT");
 * generator.getParameters().getBarcode().getQR().setQrEncodeMode(QREncodeMode.ECI_ENCODING);
 * generator.getParameters().getBarcode().getQR().setQrEncodeType(QREncodeType.FORCE_QR);
 * generator.getParameters().getBarcode().getQR().setQrECIEncoding(ECIEncodings.UTF_8);
 * generator.save("test.png", BarCodeImageFormat.PNG);
 *
 * @enum
 */
ECIEncodings =
    {

        /**
         * ISO/IEC 8859-1 Latin alphabet No. 1 encoding. ECI Id:"\000003"
         */
        ISO_8859_1: 3,
        /**
         * ISO/IEC 8859-2 Latin alphabet No. 2 encoding. ECI Id:"\000004"
         */
        ISO_8859_2: 4,
        /**
         * ISO/IEC 8859-3 Latin alphabet No. 3 encoding. ECI Id:"\000005"
         */
        ISO_8859_3: 5,
        /**
         * ISO/IEC 8859-4 Latin alphabet No. 4 encoding. ECI Id:"\000006"
         */
        ISO_8859_4: 6,
        /**
         * ISO/IEC 8859-5 Latin/Cyrillic alphabet encoding. ECI Id:"\000007"
         */
        ISO_8859_5: 7,
        /**
         * ISO/IEC 8859-6 Latin/Arabic alphabet encoding. ECI Id:"\000008"
         */
        ISO_8859_6: 8,
        /**
         * ISO/IEC 8859-7 Latin/Greek alphabet encoding. ECI Id:"\000009"
         */
        ISO_8859_7: 9,
        /**
         * ISO/IEC 8859-8 Latin/Hebrew alphabet encoding. ECI Id:"\000010"
         */
        ISO_8859_8: 10,
        /**
         * ISO/IEC 8859-9 Latin alphabet No. 5 encoding. ECI Id:"\000011"
         */
        ISO_8859_9: 11,
        /**
         * ISO/IEC 8859-10 Latin alphabet No. 6 encoding. ECI Id:"\000012"
         */
        ISO_8859_10: 12,
        /**
         * ISO/IEC 8859-11 Latin/Thai alphabet encoding. ECI Id:"\000013"
         */
        ISO_8859_11: 13,
        //14 is reserved
        /**
         * ISO/IEC 8859-13 Latin alphabet No. 7 (Baltic Rim) encoding. ECI Id:"\000015"
         */
        ISO_8859_13: 15,
        /**
         * ISO/IEC 8859-14 Latin alphabet No. 8 (Celtic) encoding. ECI Id:"\000016"
         */
        ISO_8859_14: 16,
        /**
         * ISO/IEC 8859-15 Latin alphabet No. 9 encoding. ECI Id:"\000017"
         */
        ISO_8859_15: 17,
        /**
         * ISO/IEC 8859-16 Latin alphabet No. 10 encoding. ECI Id:"\000018"
         */
        ISO_8859_16: 18,
        //19 is reserved
        /**
         * Shift JIS (JIS X 0208 Annex 1 + JIS X 0201) encoding. ECI Id:"\000020"
         */
        Shift_JIS: 20,
        //
        /**
         * Windows 1250 Latin 2 (Central Europe) encoding. ECI Id:"\000021"
         */
        Win1250: 21,
        /**
         * Windows 1251 Cyrillic encoding. ECI Id:"\000022"
         */
        Win1251: 22,
        /**
         * Windows 1252 Latin 1 encoding. ECI Id:"\000023"
         */
        Win1252: 23,
        /**
         * Windows 1256 Arabic encoding. ECI Id:"\000024"
         */
        Win1256: 24,
        //
        /**
         * ISO/IEC 10646 UCS-2 (High order byte first) encoding. ECI Id:"\000025"
         */
        UTF16BE: 25,
        /**
         * ISO/IEC 10646 UTF-8 encoding. ECI Id:"\000026"
         */
        UTF8: 26,
        //
        /**
         * ISO/IEC 646:1991 International Reference Version of ISO 7-bit coded character set encoding. ECI Id:"\000027"
         */
        US_ASCII: 27,
        /**
         * Big 5 (Taiwan) Chinese Character Set encoding. ECI Id:"\000028"
         */
        Big5: 28,
        /**
         * GB (PRC) Chinese Character Set encoding. ECI Id:"\000029"
         */
        GB18030: 29,
        /**
         * Korean Character Set encoding. ECI Id:"\000030"
         */
        EUC_KR: 30,
        /**
         * No Extended Channel Interpretation
         */
        NONE: 0
    };

/**
 * <p>Enable checksum during generation for 1D barcodes.</p>
 * <p>Default is treated as Yes for symbologies which must contain checksum, as No where checksum only possible.</p>
 * <p>Checksum never used: Codabar</p>
 * <p>Checksum is possible: Code39 Standard/Extended, Standard2of5, Interleaved2of5, Matrix2of5, ItalianPost25, DeutschePostIdentcode, DeutschePostLeitcode, VIN</p>
 * <p>Checksum always used: Rest symbologies</p>
 * @enum
 */
EnableChecksum =
    {

        /**
         * <p>
         * If checksum is required by the specification - it will be attached.
         * </p>
         */
        DEFAULT: 0,
        /**
         * <p>
         * Always use checksum if possible.
         * </p>
         */
        YES: 1,
        /**
         * <p>
         * Do not use checksum.
         * </p>
         */
        NO: 2
    };

/**
 * Function codewords for Code 128 emulation. Applied for MicroPDF417 only. Ignored for PDF417 and MacroPDF417 barcodes.
 * @enum
 */
Code128Emulation =
    {
        /**
         * No Code 128 emulation
         */
        NONE: 0,

        /**
         * UCC/EAN-128 emulation. Text compactionmode implied.
         */
        CODE_903: 903,

        /**
         * UCC/EAN-128 emulation. Numeric compactionmode implied.
         */
        CODE_904: 904,

        /**
         * UCC/EAN-128 emulation. Implied 01 AI and 14-digit codetext.
         */
        CODE_905: 905
    }

/**
 *  Specifies the file format of the image.
 * @enum
 */
BarCodeImageFormat =
    {
        /**
         * Specifies the bitmap (BMP) image format.
         */
        BMP:0,

        /**
         * Specifies the Graphics Interchange Format (GIF) image format.
         */
        GIF:1,

        /**
         * Specifies the Joint Photographic Experts Group (JPEG) image format.
         */
        JPEG:2,

        /**
         * Specifies the W3C Portable Network Graphics (PNG) image format.
         */
        PNG:3,

        /**
         * Specifies the Tagged Image File Format (TIFF) image format.
         */
        TIFF:4,


        /**
         * Specifies the Tagged Image File Format (TIFF) image format in CMYK color model.
         */
        TIFF_IN_CMYK:5,

        /**
         * Specifies the Enhanced Metafile (EMF) image format.
         */
        EMF:6,

        /**
         * Specifies the Scalable Vector Graphics (SVG) image format.
         */
        SVG:7
    };

TwoDComponentType =
{
    /**
     * Auto select type of 2D component
     */
    AUTO:0,

    /**
     * CC-A type of 2D component. It is a structural variant of MicroPDF417
     */
    CC_A:1,

    /**
     * CC-B type of 2D component. It is a MicroPDF417 symbol.
     */
    CC_B:2,

    /**
     * CC-C type of 2D component. It is a PDF417 symbol.
     */
    CC_C:3
}

module.exports = {
    BarcodeGenerator,
    EncodeTypes,
    BarcodeParameters,
    BaseGenerationParameters,
    BorderParameters,
    ChecksumValidation,
    CaptionParameters,
    BorderDashStyle,
    AutoSizeMode,
    PatchFormat,
    PatchCodeParameters,
    DataMatrixEncodeMode,
    ECIEncodings,
    QrExtCodetextBuilder,
    ExtCodetextBuilder,
    Unit,
    Padding,
    CodetextParameters,
    BarCodeImageFormat,
    PostalParameters,
    AustralianPostParameters,
    CodablockParameters,
    DataBarParameters,
    DataMatrixParameters,
    Code16KParameters,
    DotCodeParameters,
    ITFParameters,
    QrParameters,
    Pdf417Parameters,
    SupplementParameters,
    MaxiCodeParameters,
    AztecParameters,
    CodabarParameters,
    CouponParameters,
    FontUnit,
    QrStructuredAppendParameters,
    BarcodeClassifications,
    FontStyle,
    CodabarSymbol,
    ITF14BorderType,
    QREncodeMode,
    DataMatrixEccType,
    QRVersion,
    AztecSymbolMode,
    Pdf417ErrorLevel,
    Pdf417CompactionMode,
    QRErrorLevel,
    QREncodeType,
    CodabarChecksumMode,
    CodeLocation,
    FontMode,
    TextAlignment,
    GraphicsUnit,
    MacroCharacter,
    EnableChecksum,
    TwoDComponentType,
    GS1CompositeBarParameters
};